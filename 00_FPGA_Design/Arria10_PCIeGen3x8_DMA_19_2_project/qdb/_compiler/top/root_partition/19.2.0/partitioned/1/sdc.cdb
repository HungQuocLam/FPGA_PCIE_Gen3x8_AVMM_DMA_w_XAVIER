22 serialization::archive 13 0 0 0 0 9 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 0 0 12 0 0 0 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 46 top_emif_0_altera_emif_arch_nf_191_bclhany.sdc 50874 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing constraints of the memory device and
# of the memory interface

# ------------------------------------------- #
# -                                         - #
# --- Some useful functions and variables --- #
# -                                         - #
# ------------------------------------------- #

set script_dir [file dirname [info script]]
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_ip_parameters.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_parameters.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl"

#--------------------------------------------#
# -                                        - #
# --- Determine when SDC is being loaded --- #
# -                                        - #
#--------------------------------------------#

set syn_flow 0
set sta_flow 0
set fit_flow 0
set pow_flow 0
if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
   set syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
   set sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
   set fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
   set pow_flow 1
}
set ::io_only_analysis 0

# ------------------------ #
# -                      - #
# --- GENERAL SETTINGS --- #
# -                      - #
# ------------------------ #

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty

# Debug switch. Change to 1 to get more run-time debug information
set debug 0

# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ top_emif_0_altera_emif_arch_nf_191_bclhany_are_entity_names_on ]

# ---------------------- #
# -                    - #
# --- DERIVED TIMING --- #
# -                    - #
# ---------------------- #

# PLL multiplier to mem clk
regexp {([0-9\.]+) ps} $var(PLL_REF_CLK_FREQ_PS_STR) match var(PHY_REF_CLK_FREQ_PS)
regexp {([0-9\.]+) ps} $var(PLL_VCO_FREQ_PS_STR) match var(PHY_VCO_FREQ_PS)
set pll_multiplier [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(PHY_REF_CLK_FREQ_MHZ)] ]
set vco_multiplier [expr int($var(PHY_REF_CLK_FREQ_PS)/$var(PHY_VCO_FREQ_PS))]

# Half of memory clock cycle
set half_period [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr $var(UI) / 2.0 ] ]

# Half of reference clock
set ref_period      [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr $var(PHY_REF_CLK_FREQ_PS)/1000.0] ]
set ref_half_period [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr $ref_period / 2.0 ] ]

# Other clock periods
set tCK_AFI     [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(USER_CLK_RATIO) ] ]
set tCK_C2P_P2C [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(C2P_P2C_CLK_RATIO) ] ]
set tCK_PHY     [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(PHY_HMC_CLK_RATIO) ] ]

# Asymmetric uncertainties on address and command paths
set ac_min_delay [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr - $var(tIH) + $var(CA_TO_CK_BD_PKG_SKEW) ]]
set ac_max_delay [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [ expr   $var(tIS) + $var(CA_TO_CK_BD_PKG_SKEW) ]]

# ---------------------- #
# -                    - #
# --- INTERFACE RATE --- #
# -                    - #
# ---------------------- #

# -------------------------------------------------------------------- #
# -                                                                  - #
# --- This is the main call to the netlist traversal routines      --- #
# --- that will automatically find all pins and registers required --- #
# --- to apply timing constraints.                                 --- #
# --- During the fitter, the routines will be called only once     --- #
# --- and cached data will be used in all subsequent calls.        --- #
# -                                                                  - #
# -------------------------------------------------------------------- #

if { ! [ info exists top_emif_0_altera_emif_arch_nf_191_bclhany_sdc_cache ] } {
   top_emif_0_altera_emif_arch_nf_191_bclhany_initialize_ddr_db top_emif_0_altera_emif_arch_nf_191_bclhany_ddr_db var
   set top_emif_0_altera_emif_arch_nf_191_bclhany_sdc_cache 1
} else {
   if { $debug } {
      post_message -type info "SDC: reusing cached DDR DB"
   }
}

# ------------------------------------------------------------- #
# -                                                           - #
# --- If multiple instances of this core are present in the --- #
# --- design they will all be constrained through the       --- #
# --- following loop                                        --- #
# -                                                           - #
# ------------------------------------------------------------- #

set instances [ array names top_emif_0_altera_emif_arch_nf_191_bclhany_ddr_db ]
foreach { inst } $instances {
   if { [ info exists pins ] } {
      unset pins
   }
   array set pins $top_emif_0_altera_emif_arch_nf_191_bclhany_ddr_db($inst)

   # ----------------------- #
   # -                     - #
   # --- REFERENCE CLOCK --- #
   # -                     - #
   # ----------------------- #

   # First determine if a reference clock has already been created (i.e. Reference clock sharing)
   set ref_clock_exists [ top_emif_0_altera_emif_arch_nf_191_bclhany_does_ref_clk_exist $pins(pll_ref_clock) ]
   if { $ref_clock_exists == 0 }  {
      # This is the reference clock used by the PLL to derive any other clock in the core
      create_clock -period $ref_period -waveform [ list 0 $ref_half_period ] $pins(pll_ref_clock) -add -name ${inst}_ref_clock
   }
   set pins(ref_clock_name) [top_emif_0_altera_emif_arch_nf_191_bclhany_get_clock_name_from_pin_name $pins(pll_ref_clock)]

   # ------------------ #
   # -                - #
   # --- PLL CLOCKS --- #
   # -                - #
   # ------------------ #

   # VCO clock
   #We also detect and save the index of the clocks that drive the CPAs
   set is_master [expr {([string compare $inst $pins(master_instname)] == 0) ? 1 : 0}]
   set i_vco_clock 0
   set i_cpa_clock_tile_pri -1
   set i_cpa_clock_tile_sec -1
   foreach { vco_clock } $pins(pll_vco_clock) {

      set suffix "_${i_vco_clock}"
      if {$vco_clock == $pins(master_vco_clock)} {
         set suffix ""
         if {$is_master} {
            set i_cpa_clock_tile_pri $i_vco_clock
         }
      } elseif {$vco_clock == $pins(master_vco_clock_sec)} {
         if {$is_master} {
            set i_cpa_clock_tile_sec $i_vco_clock
         }
      }

      set local_pll_vco_clk_${i_vco_clock} [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
         -target $vco_clock \
         -name "${inst}_vco_clk${suffix}" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]
      incr i_vco_clock
   }
   
   if {! $var(IS_HPS)} {
      if {$is_master} {
         if {$i_cpa_clock_tile_pri == -1} {
            post_message -type critical_warning "Failed to find CPA clock index"
         }
         if {$i_cpa_clock_tile_sec == -1 && $var(PHY_PING_PONG_EN)} {
            post_message -type critical_warning "Failed to find CPA clock index for secondary interface"
         }
      }
   }

   # Core clocks
   set core_clocks [list]
   set core_clocks_local [list]

   # Skip if we're in HPS mode since there's no user accessible core clock
   # and there's no transfers within core fabric to analyze
   if {! $var(IS_HPS)} {

      set local_pll_master_vco_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
         -target $pins(master_vco_clock) \
         -name "${pins(master_instname)}_vco_clk" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]

      # emif_usr_clk
      # Clock only exists when HMC is used.
      set local_core_usr_clock ""
      if {$pins(master_core_usr_clock) != ""} {
         set name "core_usr_clk"
         set master_core_clock $pins(master_core_usr_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock)
         lappend core_clocks_local $local_core_usr_clock 
      }
      
      # emif_usr_clk_sec
      # Clock only exists when ping-pong HMC is used
      set local_core_usr_clock_sec ""
      if {$pins(master_core_usr_clock_sec) != ""} {
         set name "core_usr_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock_sec [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock_sec)
         lappend core_clocks_local $local_core_usr_clock_sec 
      }      

      # emif_usr_half_clk
      # Clock only exists when HMC is used and in 2x bridge mode
      set local_core_usr_half_clock ""
      if {$pins(master_core_usr_half_clock) != ""} {
         set name "core_usr_half_clk"
         set master_core_clock $pins(master_core_usr_half_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock)
         lappend core_clocks_local $local_core_usr_half_clock
      }
      
      # emif_usr_half_clk
      # Clock only exists when ping-pong HMC is used and in 2x bridge mode
      set local_core_usr_half_clock_sec ""
      if {$pins(master_core_usr_half_clock_sec) != ""} {
         set name "core_usr_half_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_half_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock_sec)
         lappend core_clocks_local $local_core_usr_half_clock
      }      

      # afi_clk
      # Clock only exists when HMC isn't used.
      set local_core_afi_clock ""
      if {$pins(master_core_afi_clock) != ""} {
         set name "core_afi_clk"
         set master_core_clock $pins(master_core_afi_clock)
         if {$var(USER_CLK_RATIO) == 8} {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) / 2}]
         } else {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         }
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_afi_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_afi_clock)
         lappend core_clocks_local $local_core_afi_clock
      }

      # afi_half_clk
      # Clock only exists when HMC isn't used.
      set local_core_afi_half_clock ""
      if {$pins(master_core_afi_half_clock) != ""} {
         set name "core_afi_half_clk"
         set master_core_clock $pins(master_core_afi_half_clock)
         if {$var(USER_CLK_RATIO) == 8} {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         } else {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         }
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_afi_half_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_afi_half_clock)
         lappend core_clocks_local $local_core_afi_half_clock
      }

      # extra CPA output for PE test purpose.
      set local_core_dft_cpa_1_clock "" 
      if {$pins(master_core_dft_cpa_1_clock) != ""} {
         set name "core_dft_cpa_1_clk"
         set master_core_clock $pins(master_core_dft_cpa_1_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_dft_cpa_1_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_dft_cpa_1_clock)
         lappend core_clocks_local $local_core_dft_cpa_1_clock
      }
      
      # Calibration master logic clock
      if {$pins(master_cal_master_clk) != ""} {
         set pll_cal_master_clk [get_pins -nowarn $pins(master_cal_master_clk)]

         if {[get_collection_size $pll_cal_master_clk] > 0} {
            set name              "core_cal_master_clk"
            set master_core_clock $pins(master_cal_master_clk)
            set divide_by         $var(pll_c4_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_4) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c4_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_4)
            
            set local_cal_master_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_master_clk)
            lappend core_clocks_local $local_cal_master_clock
         }
      }      
      
      # Calibration slave logic clock
      if {$pins(master_cal_slave_clk) != ""} {
         set pll_cal_slave_clk [get_pins -nowarn $pins(master_cal_slave_clk)]

         if {[get_collection_size $pll_cal_slave_clk] > 0} {
            set name              "core_cal_slave_clk"
            set master_core_clock $pins(master_cal_slave_clk)
            set divide_by         $var(pll_c3_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_3) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c3_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_3)
            
            set local_cal_slave_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_slave_clk)
            lappend core_clocks_local $local_cal_slave_clock
         }
      }

      # User-mode OCT Clock Constraint
      set local_core_usermode_oct_clock ""
      if {$pins(usermode_oct_clock) != ""} {
         set local_core_usermode_oct_clock [top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $pins(usermode_oct_clock) \
            -name "${inst}_oct_clock" \
            -source $pins(pll_ref_clock) \
            -multiply_by 1 \
            -divide_by 16 \
            -phase 0 ]

         lappend core_clocks $pins(usermode_oct_clock)
         lappend core_clocks_local $local_core_usermode_oct_clock

      }

      if {$pins(usermode_oct_gated_clock) != ""} {
         set local_core_usermode_oct_gated_clock [top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $pins(usermode_oct_gated_clock) \
            -name "${inst}_oct_gated_clock" \
            -source $pins(usermode_oct_clock) \
            -multiply_by 1 \
            -divide_by 1 \
            -phase 0 ]

         lappend core_clocks $pins(usermode_oct_gated_clock)
         lappend core_clocks_local $local_core_usermode_oct_gated_clock

         set_clock_uncertainty -from [get_clocks $local_core_usermode_oct_clock] -to [get_clocks $local_core_usermode_oct_gated_clock] -suppress_warnings -setup 5ns
         set_clock_uncertainty -from [get_clocks $local_core_usermode_oct_clock] -to [get_clocks $local_core_usermode_oct_gated_clock] -suppress_warnings -enable_same_physical_edge -hold 5ns

         set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.r_cal_rdy_metasync\[0\]"]
         set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.r_cal_req_metasync\[0\]"]
         set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.r_cal_rst_metasync\[0\]"]

         if {$var(PHY_PERIODIC_OCT_RECAL)} {
            set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.gen_oct_recal_s2p_handshake.r_s2pload_rdy_metasync\[0\]"]
            set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.gen_oct_recal_s2p_handshake.r_s2pload_ena_metasync\[0\]"]
            set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.gen_oct_recal_timer.r_oct_recal_req_metasync\[0\]"]
         }
      }

      # Optional PLL Extra clocks
      for {set i_extra_clk 0} {$i_extra_clk < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i_extra_clk} {
         set pll_extra_clk [get_pins -nowarn $pins(pll_extra_clk_${i_extra_clk})]

         # PLL counter may not exist if clock isn't actually connected and used
         if {[get_collection_size $pll_extra_clk] > 0} {
            set i_clk_cnt_num     [expr {$i_extra_clk + $var(pll_num_of_reserved_cnts)}]
            set name              "core_extra_clk_${i_extra_clk}"
            set master_core_clock $pins(pll_extra_clk_${i_extra_clk})
            set divide_by         $var(pll_c${i_clk_cnt_num}_cnt)
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_${i_clk_cnt_num}) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c${i_clk_cnt_num}_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_${i_clk_cnt_num})

            set local_pll_extra_clock [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]
         }
      }
   } else {
      # User-mode OCT Clock Constraint
      set local_core_usermode_oct_clock ""
      if {$pins(usermode_oct_clock) != ""} {
         set local_core_usermode_oct_clock [top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $pins(usermode_oct_clock) \
            -name "${inst}_oct_clock" \
            -source "$pins(usermode_oct_clock)|clk" \
            -multiply_by 1 \
            -divide_by 16 \
            -phase 0 ]

         lappend core_clocks $pins(usermode_oct_clock)
         lappend core_clocks_local $local_core_usermode_oct_clock

      }

      if {$pins(usermode_oct_gated_clock) != ""} {
         set local_core_usermode_oct_gated_clock [top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
            -target $pins(usermode_oct_gated_clock) \
            -name "${inst}_oct_gated_clock" \
            -source $pins(usermode_oct_clock) \
            -multiply_by 1 \
            -divide_by 1 \
            -phase 0 ]

         lappend core_clocks $pins(usermode_oct_gated_clock)
         lappend core_clocks_local $local_core_usermode_oct_gated_clock

         set_clock_uncertainty -from [get_clocks $local_core_usermode_oct_clock] -to [get_clocks $local_core_usermode_oct_gated_clock] -suppress_warnings -setup 5ns
         set_clock_uncertainty -from [get_clocks $local_core_usermode_oct_clock] -to [get_clocks $local_core_usermode_oct_gated_clock] -suppress_warnings -enable_same_physical_edge -hold 5ns

         set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.r_cal_rdy_metasync\[0\]"]
         set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.r_cal_req_metasync\[0\]"]
         set_false_path -to [get_registers "${inst}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.r_cal_rst_metasync\[0\]"]
      }
   }

   # Periphery clocks
   set periphery_clocks [list]
   set i_phy_clock 0
   foreach { phy_clock } $pins(pll_phy_clock) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(PHY_HMC_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_${i_phy_clock} [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
         -target $phy_clock \
         -name "${inst}_phy_clk_${i_phy_clock}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_${i_phy_clock}]
      incr i_phy_clock
   }

   set i_phy_clock_l 0
   foreach { phy_clock_l } $pins(pll_phy_clock_l) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(C2P_P2C_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_l_${i_phy_clock_l} [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
         -target $phy_clock_l \
         -name "${inst}_phy_clk_l_${i_phy_clock_l}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock_l] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_l_${i_phy_clock_l}]
      incr i_phy_clock_l
   }

   # ------------------------ #
   # -                      - #
   # --- WRITE FIFO CLOCK --- #
   # -                      - #
   # ------------------------ #

   set write_fifo_clk [get_keepers ${inst}*|tile_gen[*].lane_gen[*].lane_inst~out_phy_reg]

   set i_wf_clock 0
   foreach_in_collection wf_clock $write_fifo_clk {
      set vco_clock_id [top_emif_0_altera_emif_arch_nf_191_bclhany_get_vco_clk_id $wf_clock var]
      if {$vco_clock_id == -1} {
         post_message -type critical_warning "Failed to find VCO clock"
      } else {
         set local_wf_clk_${i_wf_clock} [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock \
           -target [get_node_info -name $wf_clock] \
           -name "${inst}_wf_clk_${i_wf_clock}" \
           -source [get_node_info -name $vco_clock_id] \
           -multiply_by 1 \
           -divide_by [expr $var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)] \
           -phase 0 ]        
      }   
      incr i_wf_clock     
   }      

   # ---------------- #
   # -              - #
   # --- A/C PATH --- #
   # -              - #
   # ---------------- #

   # Only during the Fitter do we need to have constraints to allow for auto-delay chain code to
   # pick appropirate good settings
   # Also, only need it if address/command is not calibrated
   if {($fit_flow == 1) && ($var(WITH_CA_CALIB) == 0)} {
   
      # First, define CK and CK#clocks because A/C timing is defined w.r.t. to these.
      set master_ck_clock ""
      foreach ac_clk_pin $pins(ac_clk) ac_clk_pin_n $pins(ac_clk_n) {
         set master_ck_clock [get_fanins $ac_clk_pin]
         foreach_in_collection check_pin $master_ck_clock {
            set check_pin_name [get_node_info -name $check_pin]
            if {[regexp {out_phy_reg$} $check_pin_name]} {
               set master_ck_clock $check_pin_name
               break
            }
         }
         create_generated_clock -multiply_by 1 -source $master_ck_clock $ac_clk_pin -name $ac_clk_pin     
         create_generated_clock -multiply_by 1 -invert -source $master_ck_clock $ac_clk_pin_n -name $ac_clk_pin_n     
      }
   
      foreach { ac_clk_pin } $pins(ac_clk) {
         # ac_pins can contain input ports such as mem_err_out_n
         # Loop through each ac pin to make sure we only apply set_output_delay to output ports
         foreach { ac_pin } $pins(ac_sync) {
            set ac_port [ get_ports $ac_pin ]
            if {[get_collection_size $ac_port] > 0} {
               if [ get_port_info -is_output_port $ac_port ] {
                  # Specifies the minimum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -min $ac_min_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay

                  # Specifies the maximum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -max $ac_max_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay
               }
            }
         }
      }
   } else {
      set_false_path -to $pins(ac_sync)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_sync)
   }


   # ----------------- #
   # -               - #
   # --- READ PATH --- #
   # -               - #
   # ----------------- #

   foreach { read_clock } $pins(rclk) {
      create_clock -period $var(UI) -waveform [ list 0 $half_period ] $read_clock -name ${read_clock}_IN -add
   }

   # Constrain cq_n (rclk_n) for QDR2 protocols since it is a complementary clock
   if {$var(PROTOCOL) == "QDRII"} {
      foreach { read_clock } $pins(rclk_n) {
         create_clock -period $var(UI) -waveform [ list 0 $half_period ] $read_clock -name ${read_clock}_IN -add
      }
   }

   # ------------------------------ #
   # -                            - #
   # --- MULTICYCLE CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #

   if {$var(PHY_HMC_CLK_RATIO)  != $var(C2P_P2C_CLK_RATIO) } {
      set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|ctl2core_avl_cmd_ready -setup 2 -start
      set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|ctl2core_avl_cmd_ready -hold  1 -start
   }
   
   set afi_ctl2core17_pin [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[17]]
   if {[get_collection_size $afi_ctl2core17_pin] > 0} {
      set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[17] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.gen_oct_recal_ena.oct_s2pload_ena_regs* -setup 4 -start
      set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[17] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.gen_oct_recal_ena.oct_s2pload_ena_regs* -hold  3 -start
   }   

   set afi_ctl2core19_pin [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19]]
   if {[get_collection_size $afi_ctl2core19_pin] > 0} {
      set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -setup 4 -start
      set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -hold  3 -start
   }   
   
   # afi_cal_in_progress (used by cal_counter module)
   # setup=7 and hold=6 are somewhat arbitrary choices
   set tmp "${inst}|arch|arch_inst|seq_if_inst|afi_cal_in_progress_sync_inst|din_s1"
   set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
   if {[get_collection_size $tmp_pin] > 0} {
      set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
      set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
   }
   
   # afi_cal_success
   # setup=7 and hold=6 are somewhat arbitrary choices
   set tmp "${inst}|arch|arch_inst|seq_if_inst|afi_cal_success_sync_inst|din_s1"
   set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
   if {[get_collection_size $tmp_pin] > 0} {
      set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
      set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
   }
   
   # afi_cal_fail
   # setup=7 and hold=6 are somewhat arbitrary choices
   set tmp "${inst}|arch|arch_inst|seq_if_inst|afi_cal_fail_sync_inst|din_s1"
   set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
   if {[get_collection_size $tmp_pin] > 0} {
      set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
      set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
   }
   
   # cal_counter synchronizer for global_reset_n_int
   set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_reset_n|din_s1"
   set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
   if {[get_collection_size $tmp_pin] > 0} {
      set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
      set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
   }
   
   # cal_counter synchronizer for afi_cal_in_progress
   set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_cal_in_progress|din_s1"
   set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
   if {[get_collection_size $tmp_pin] > 0} {
      set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
      set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
   }

   set afi_core2ctl7_pin [get_registers -nowarn ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|sr_out[0]]
   if {[get_collection_size $afi_core2ctl7_pin] > 0} {
      set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|sr_out[0] -through [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7]] -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -setup 4 -start
      set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|sr_out[0] -through [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7]] -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -hold 3 -start
   }

   set afi_core2ctl6_pin [get_registers -nowarn ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.gen_oct_recal_rdy.oct_recal_req_regs|sr_out[0]]
   if {[get_collection_size $afi_core2ctl6_pin] > 0} {
      set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.gen_oct_recal_rdy.oct_recal_req_regs|sr_out[0] -through [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[6]] -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -setup 4 -start
      set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.gen_oct_recal_rdy.oct_recal_req_regs|sr_out[0] -through [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[6]] -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -hold 3 -start
   }

   set afi_core2ctl5_pin [get_registers -nowarn ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.gen_oct_recal_rdy.oct_s2pload_ena_regs|sr_out[0]]
   if {[get_collection_size $afi_core2ctl5_pin] > 0} {
      set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.gen_oct_recal_rdy.oct_s2pload_ena_regs|sr_out[0] -through [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[5]] -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -setup 4 -start
      set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.gen_oct_recal_rdy.oct_s2pload_ena_regs|sr_out[0] -through [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[5]] -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -hold 3 -start
   }
   
   set lane_reset_pin [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|reset_n]
   if {[get_collection_size $lane_reset_pin] > 0} {
      set_multicycle_path -from * -through $lane_reset_pin -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst* -setup 7 -end
      set_multicycle_path -from * -through $lane_reset_pin -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst* -hold 6 -end
   }

   set tile_reset_pin [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst*|global_reset_n]
   if {[get_collection_size $tile_reset_pin] > 0} {
      set_multicycle_path -from * -through $tile_reset_pin -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst* -setup 7 -end
      set_multicycle_path -from * -through $tile_reset_pin -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst* -hold 6 -end
   }

   set io_aux_reset_pin [get_pins -nowarn ${inst}|arch|arch_inst|io_aux_inst|io_aux|core_usr_reset_n]
   if {[get_collection_size $io_aux_reset_pin] > 0} {
      set_multicycle_path -from * -through $io_aux_reset_pin -to ${inst}|arch|arch_inst|io_aux_inst|io_aux* -setup 7 -end
      set_multicycle_path -from * -through $io_aux_reset_pin -to ${inst}|arch|arch_inst|io_aux_inst|io_aux* -hold 6 -end
   }
   
   if {!$var(IS_HPS)} {
      # Soft reset synchronizers
      # See RTL for the justification of setup=7 and hold=6
      set reset_sync_clrn_pin [get_pins -nowarn ${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync*|clrn]
      if {[get_collection_size $reset_sync_clrn_pin] > 0} {
         set_multicycle_path -through $reset_sync_clrn_pin -to ${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync* -setup 7 -end
         set_multicycle_path -through $reset_sync_clrn_pin -to ${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync* -hold 6 -end
      }
   }

   if {!$var(IS_HPS)} {
      set lane_reg [get_keepers -nowarn ${inst}*|tile_gen[*].lane_gen[*].lane_inst~lane_reg]
      if {[get_collection_size $lane_reg] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -to $lane_reg -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|core_dll[2] -setup 8 -end
            set_multicycle_path -to $lane_reg -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|core_dll[2] -hold  7 -end
         } else {
            set_false_path -to $lane_reg -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|core_dll[2]
         }
      }
   }

   if {[info exists var(PHY_DLL_CORE_UPDN_EN)] && $var(PHY_DLL_CORE_UPDN_EN)} {
      set lane_reg [get_keepers -nowarn ${inst}*|tile_gen[*].lane_gen[*].lane_inst~lane_reg]
      set_multicycle_path -to $lane_reg -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|core_dll[1] -setup 9 -end
      set_multicycle_path -to $lane_reg -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|core_dll[1] -hold  7 -end
      set_multicycle_path -to $lane_reg -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|core_dll[0] -setup 9 -end
      set_multicycle_path -to $lane_reg -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|core_dll[0] -hold  7 -end
   }

   # ------------------------------ #
   # -                            - #
   # --- FALSE PATH CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #

   # DQ/DQS pins are calibrated
   set_false_path -to $pins(wdata)
   set_false_path -from $pins(rdata)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wdata)
   set_input_delay -clock $pins(ref_clock_name) 0 $pins(rdata)
   if {[llength $pins(dm)] > 0} {
      set_false_path -to $pins(dm)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dm)
   }
   if {[llength $pins(dbi)] > 0} {
      set_false_path -to $pins(dbi)
      set_false_path -from $pins(dbi)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
      set_input_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
   }
   set_false_path -to $pins(wclk)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk)
   if {[llength $pins(wclk_n)] > 0} {
      set_false_path -to $pins(wclk_n)
	  set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk_n)
   }
   set_false_path -from $pins(rclk)
   if {[llength $pins(rclk_n)] > 0} {
      set_false_path -from $pins(rclk_n)
   }
   if {[llength $pins(ac_clk)] > 0} {
      set_false_path -to $pins(ac_clk)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk) -add
   }
   if {[llength $pins(ac_clk_n)] > 0} {
      set_false_path -to $pins(ac_clk_n)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk_n) -add
   }

   if {[llength $pins(ac_async)] > 0} {
      set_false_path -to $pins(ac_async)
      set_false_path -from $pins(ac_async)
      foreach ac_async $pins(ac_async) {
         if {[get_port_info -is_input $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_input_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
         if {[get_port_info -is_output $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_output_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
      }
   }

   # ------------------------- #
   # -                       - #
   # --- CLOCK UNCERTAINTY --- #
   # -                       - #
   # ------------------------- #

   if {!$var(IS_HPS) && ($fit_flow == 1 || $sta_flow == 1)} {

      #################################
      # C2P/P2C transfers
      #################################

      # Get P2C / C2P Multi-tile clock uncertainty
      set p2c_c2p_multi_tile_clock_uncertainty [top_emif_0_altera_emif_arch_nf_191_bclhany_get_p2c_c2p_clock_uncertainty $inst var]

      # Get extra periphery clock uncertainty
      set periphery_clock_uncertainty [list]
      top_emif_0_altera_emif_arch_nf_191_bclhany_get_periphery_clock_uncertainty periphery_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         top_emif_0_altera_emif_arch_nf_191_bclhany_get_periphery_overconstraints periphery_overconstraints_st periphery_overconstraints_mt var
      } else {
         set periphery_overconstraints_st [list 0.0 0.0 0.0 0.0]
         set periphery_overconstraints_mt [list 0.0 0.0 0.0 0.0]
      }

      # Now loop over core/periphery clocks and set clock uncertainty
      set i_core_clock 0
      foreach core_clock $core_clocks {
         if {$core_clock != ""} {

            set local_core_clock [lindex $core_clocks_local $i_core_clock]
            
            if {$core_clock == $pins(master_core_usr_clock_sec) || $core_clock == $pins(master_core_usr_half_clock_sec)} {
               set same_tile_index $i_cpa_clock_tile_sec
            } else {
               set same_tile_index $i_cpa_clock_tile_pri
            }

            set i_phy_clock 0
            foreach { phy_clock } $pins(pll_phy_clock_l) {
               
               if {$i_phy_clock != $same_tile_index} {
                  # C2P/P2C where the periphery tile != CPA tile.
                  # For these transfers the SDC explicitly overrides the clock uncertainty values.
                  # Therefore, when overconstraining we must not use the "-add" option.
                  set add_to_derived ""
                  set c2p_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 0] + [lindex $periphery_clock_uncertainty 0]}]
                  set c2p_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 1] + [lindex $periphery_clock_uncertainty 1]}]
                  set p2c_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 2] + [lindex $periphery_clock_uncertainty 2]}]
                  set p2c_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 3] + [lindex $periphery_clock_uncertainty 3]}]
               } else {
                  # C2P/P2C where the periphery tile == CPA tile
                  # For these transfers it is safe to use the -add option since we rely on 
                  # derive_clock_uncertainty for the base value.
                  set add_to_derived "-add"
                  set c2p_su         [expr [lindex $periphery_overconstraints_st 0] + [lindex $periphery_clock_uncertainty 0]]
                  set c2p_h          [expr [lindex $periphery_overconstraints_st 1] + [lindex $periphery_clock_uncertainty 1]]
                  set p2c_su         [expr [lindex $periphery_overconstraints_st 2] + [lindex $periphery_clock_uncertainty 2]]
                  set p2c_h          [expr [lindex $periphery_overconstraints_st 3] + [lindex $periphery_clock_uncertainty 3]]
               }

               set catch_exception [catch {set local_phy_clk_l_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup $add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  $add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup $add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  $add_to_derived $p2c_h
               }

               set catch_exception [catch {set local_phy_clk_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup $add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  $add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup $add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  $add_to_derived $p2c_h
               }

               incr i_phy_clock
            }
         }
         incr i_core_clock
      }

      #################################
      # Within-core transfers
      #################################

      # Get extra core clock uncertainty
      set core_clock_uncertainty [list]
      top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_clock_uncertainty core_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_overconstraints core_overconstraints var
      } else {
         set core_overconstraints [list 0.0 0.0 0.0 0.0]
      }

      set c2c_same_su         [expr [lindex $core_overconstraints 0] + [lindex $core_clock_uncertainty 0]]
      set c2c_same_h          [expr [lindex $core_overconstraints 1] + [lindex $core_clock_uncertainty 1]]
      set c2c_diff_su         [expr [lindex $core_overconstraints 2] + [lindex $core_clock_uncertainty 2]]
      set c2c_diff_h          [expr [lindex $core_overconstraints 3] + [lindex $core_clock_uncertainty 3]]

      # For these transfers it is safe to use the -add option of set_clock_uncertainty since
      # we rely on derive_clock_uncertainty for the base value.
      foreach src_core_clock_local $core_clocks_local {
         if {$src_core_clock_local != ""} {
            foreach dst_core_clock_local $core_clocks_local {
               if {$dst_core_clock_local != ""} {
                  if {$src_core_clock_local == $dst_core_clock_local} {
                     # Same clock network transfers
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_same_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -enable_same_physical_edge -add $c2c_same_h
                  } else {
                     # Transfers between different core clock networks
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_diff_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -add $c2c_diff_h
                  }
               }
            }
         }
      }

   }

   # --------------------- #
   # -                   - #
   # --- ACTIVE CLOCKS --- #
   # -                   - #
   # --------------------- #

   if {(($::quartus(nameofexecutable) ne "quartus_fit") && ($::quartus(nameofexecutable) ne "quartus_map"))} {

      if {$var(C2P_P2C_PR) && [llength $periphery_clocks] > 0 && !$debug} {
         post_sdc_message info "Setting periphery clocks as inactive; use Report DDR to timing analyze periphery clocks"
         set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $periphery_clocks]]
      }
   }


}

# -------------------------- #
# -                        - #
# --- REPORT DDR COMMAND --- #
# -                        - #
# -------------------------- #

add_ddr_report_command "source [list [file join [file dirname [info script]] ${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename}_report_timing.tcl]]"

 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 60 top_emif_0_altera_emif_arch_nf_191_bclhany_ip_parameters.tcl 35612 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface

package require ::quartus::emif_timing_model
package require ::quartus::clock_uncertainty


set ::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename top_emif_0_altera_emif_arch_nf_191_bclhany

set var(PROTOCOL)                                                DDR4
set var(NUM_RANKS)                                               1
set var(SLEW_RATE_DRAM)                                          4.0
set var(SLEW_RATE_DRAM_CLOCK)                                    8.0
set var(VIN_Ms)                                                  0.136
set var(VIN_Mh)                                                  0.068
set var(SLEW_RATE_PHY)                                           2.0
set var(SLEW_RATE_PHY_CLOCK)                                     4.0
set var(SLEW_RATE_CA)                                            2.0
set var(SLEW_RATE_CLOCK)                                         4.0
set var(UI)                                                      0.937
set var(tCK)                                                     0.75
set var(tDQSQ)                                                   0.050625
set var(tQH)                                                     0.4325
set var(tDS)                                                     0.04687498535156709
set var(tDH)                                                     0.04687498535156709
set var(tIS)                                                     0.06
set var(tIH)                                                     0.095
set var(tDQSCK)                                                  0.165
set var(tDQSS)                                                   0.27
set var(tWLS)                                                    0.121
set var(tWLH)                                                    0.121
set var(tDSS)                                                    0.18
set var(tDSH)                                                    0.18
set var(BD_PKG_SKEW)                                             0.02
set var(CA_BD_PKG_SKEW)                                          0.18
set var(CA_TO_CK_BD_PKG_SKEW)                                    0.0
set var(DQS_BOARD_SKEW)                                          0.02
set var(DQS_TO_CK_BOARD_SKEW)                                    0.02
set var(RD_ISI)                                                  0.12
set var(WR_ISI)                                                  0.13
set var(CA_ISI)                                                  0.17
set var(DQSG_ISI)                                                0.17
set var(WL_ISI)                                                  0.06
set var(X4)                                                      0
set var(IS_DLL_ON)                                               1
set var(OCT_RECAL)                                               0
set var(RDBI)                                                    0
set var(WDBI)                                                    0
set var(TERMINATION_LESS_THAN_120)                               1
set var(IS_COMPONENT)                                            0

set var(PHY_TARGET_SPEEDGRADE)                                   I1
set var(PHY_TARGET_IS_ES)                                        false
set var(PHY_TARGET_IS_ES2)                                       false
set var(PHY_TARGET_IS_ES3)                                       false
set var(PHY_TARGET_IS_PRODUCTION)                                true
set var(PHY_CORE_CLKS_SHARING_ENUM)                              CORE_CLKS_SHARING_DISABLED
set var(PHY_CONFIG_ENUM)                                         CONFIG_PHY_AND_HARD_CTRL
set var(PHY_PING_PONG_EN)                                        false
set var(PHY_DLL_CORE_UPDN_EN)                                    false
set var(IS_HPS)                                                  false
set var(IS_VID)                                                  false
set var(PHY_MEM_CLK_FREQ_MHZ)                                    1066.667
set var(PHY_REF_CLK_FREQ_MHZ)                                    133.333
set var(PHY_REF_CLK_JITTER_PS)                                   10.0
set var(PLL_REF_CLK_FREQ_PS_STR)                                 "7504 ps"
set var(PLL_VCO_FREQ_PS_STR)                                     "938 ps"
set var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)                           1
set var(PLL_PHY_CLK_VCO_PHASE)                                   1
set var(USER_CLK_RATIO)                                          4
set var(C2P_P2C_CLK_RATIO)                                       4
set var(PHY_HMC_CLK_RATIO)                                       2
set var(MEM_FORMAT_ENUM)                                         MEM_FORMAT_UDIMM
set var(MEM_DATA_MASK_EN)                                        true
set var(DIAG_TIMING_REGTEST_MODE)                                false
set var(DIAG_CPA_OUT_1_EN)                                       false
set var(DIAG_USE_CPA_LOCK)                                       false
set var(PHY_USERMODE_OCT)                                        false
set var(PHY_PERIODIC_OCT_RECAL)                                  false
set var(PLL_NUM_OF_EXTRA_CLKS)                                   0
set var(PLL_C_CNT_LOW_3)                                         3
set var(PLL_C_CNT_HIGH_3)                                        4
set var(PLL_C_CNT_BYPASS_EN_3)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_3)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_3)                                  50
set var(PLL_C_CNT_LOW_4)                                         3
set var(PLL_C_CNT_HIGH_4)                                        4
set var(PLL_C_CNT_BYPASS_EN_4)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_4)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_4)                                  50
set var(PLL_C_CNT_LOW_5)                                         256
set var(PLL_C_CNT_HIGH_5)                                        256
set var(PLL_C_CNT_BYPASS_EN_5)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_5)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_5)                                  50
set var(PLL_C_CNT_LOW_6)                                         256
set var(PLL_C_CNT_HIGH_6)                                        256
set var(PLL_C_CNT_BYPASS_EN_6)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_6)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_6)                                  50
set var(PLL_C_CNT_LOW_7)                                         256
set var(PLL_C_CNT_HIGH_7)                                        256
set var(PLL_C_CNT_BYPASS_EN_7)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_7)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_7)                                  50
set var(PLL_C_CNT_LOW_8)                                         256
set var(PLL_C_CNT_HIGH_8)                                        256
set var(PLL_C_CNT_BYPASS_EN_8)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_8)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_8)                                  50

set var(C2P_SETUP_OC_NS)                                         0.000
set var(C2P_HOLD_OC_NS)                                          0.000
set var(P2C_SETUP_OC_NS)                                         0.000
set var(P2C_HOLD_OC_NS)                                          0.000
set var(C2C_SAME_CLK_SETUP_OC_NS)                                0.000
set var(C2C_SAME_CLK_HOLD_OC_NS)                                 0.000
set var(C2C_DIFF_CLK_SETUP_OC_NS)                                0.000
set var(C2C_DIFF_CLK_HOLD_OC_NS)                                 0.000
set var(C2P_P2C_PR)                                              false

set var(PATTERNS_AC_CLK)                                         [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_CLK_N)                                       [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf_bar|o]
set var(PATTERNS_AC_SYNC)                                        [list arch|arch_inst|bufs_inst|gen_mem_a.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_act_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_bg.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cke.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cs_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_odt.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_ASYNC)                                       [list arch|arch_inst|bufs_inst|gen_mem_reset_n.inst[0].b|no_oct.obuf|o]
set var(PATTERNS_RCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o]
set var(PATTERNS_RCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o]
set var(PATTERNS_WCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o]
set var(PATTERNS_WCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o]
set var(PATTERNS_RDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o]
set var(PATTERNS_WDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o]
set var(PATTERNS_DM)                                             [list ]
set var(PATTERNS_DBI)                                            [list arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[7].b|cal_oct.obuf|o]
set var(PATTERNS_ALERT_N)                                        [list ]

initialize_emiftcl -protocol $var(PROTOCOL)
initialize_clock_uncertainty_data
 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 57 top_emif_0_altera_emif_arch_nf_191_bclhany_parameters.tcl 9127 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface


set var(VIN_Cs) [expr [emiftcl_get_parameter_value -parameter VIN_Cs]/1000.0]
set var(VIN_Ch) [expr [emiftcl_get_parameter_value -parameter VIN_Ch]/1000.0]
set var(MPR_DQSQ) [emiftcl_get_parameter_value -parameter MPR_DQSQ]
set var(MPR_QH) [emiftcl_get_parameter_value -parameter MPR_QH]
set var(MPR_DS) [emiftcl_get_parameter_value -parameter MPR_DS]
set var(MPR_DH) [emiftcl_get_parameter_value -parameter MPR_DH]
set var(MPR_IS) [emiftcl_get_parameter_value -parameter MPR_IS]
set var(MPR_IH) [emiftcl_get_parameter_value -parameter MPR_IH]
set var(MPR_DQSCK) [emiftcl_get_parameter_value -parameter MPR_DQSCK]
set var(MPR_DQSS) [emiftcl_get_parameter_value -parameter MPR_DQSS]
set var(MPR_WLS) [emiftcl_get_parameter_value -parameter MPR_WLS]
set var(MPR_WLH) [emiftcl_get_parameter_value -parameter MPR_WLH]
set var(MPR_DSS) [emiftcl_get_parameter_value -parameter MPR_DSS]
set var(MPR_DSH) [emiftcl_get_parameter_value -parameter MPR_DSH]
set var(WITH_MPR) [emiftcl_get_parameter_value -parameter WITH_MPR]
set var(WITH_WL_M_CALIB) [emiftcl_get_parameter_value -parameter WITH_WL_M_CALIB]
set var(WITH_CA_CALIB) [emiftcl_get_parameter_value -parameter WITH_CA_CALIB]
set var(WITH_WL_CALIB) [emiftcl_get_parameter_value -parameter WITH_WL_CALIB]
set var(DEFAULT_BD_PKG_SKEW) [expr [emiftcl_get_parameter_value -parameter DEFAULT_BD_PKG_SKEW]/1000.0]
set var(DEFAULT_CA_BD_PKG_SKEW) [expr [emiftcl_get_parameter_value -parameter DEFAULT_CA_BD_PKG_SKEW]/1000.0]
set var(DEFAULT_CA_TO_CK_BD_PKG_SKEW) [expr [emiftcl_get_parameter_value -parameter DEFAULT_CA_TO_CK_BD_PKG_SKEW]/1000.0]
set var(BD_SK_SENS_RD) [emiftcl_get_parameter_value -parameter BD_SK_SENS_RD]
set var(BD_SK_SENS_WR) [emiftcl_get_parameter_value -parameter BD_SK_SENS_WR]
set var(BD_SK_SENS_DQSG) [emiftcl_get_parameter_value -parameter BD_SK_SENS_DQSG]
set var(BD_SK_SENS_WL) [emiftcl_get_parameter_value -parameter BD_SK_SENS_WL]
set var(BD_SK_SENS_WL_WO_CALIB) [emiftcl_get_parameter_value -parameter BD_SK_SENS_WL_WO_CALIB]
set var(BD_SK_SENS_CA) [emiftcl_get_parameter_value -parameter BD_SK_SENS_CA]
set var(BD_SK_SENS_CA_WO_CALIB) [emiftcl_get_parameter_value -parameter BD_SK_SENS_CA_WO_CALIB]
set var(EXTRACTED_PERIOD) [emiftcl_get_parameter_value -parameter EXTRACTED_PERIOD]
set var(RD_JITTER_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter RD_JITTER_SENS_TO_PERIOD]
set var(RD_CALUNC_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter RD_CALUNC_SENS_TO_PERIOD]
set var(WR_JITTER_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter WR_JITTER_SENS_TO_PERIOD]
set var(WR_CALUNC_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter WR_CALUNC_SENS_TO_PERIOD]
set var(CA_JITTER_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter CA_JITTER_SENS_TO_PERIOD]
set var(CA_CALUNC_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter CA_CALUNC_SENS_TO_PERIOD]
set var(CA_PVT_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter CA_PVT_SENS_TO_PERIOD]
set var(DQSG_JITTER_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter DQSG_JITTER_SENS_TO_PERIOD]
set var(DQSG_TRKUNC_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter DQSG_TRKUNC_SENS_TO_PERIOD]
set var(WL_JITTER_SENS_TO_PERIOD) [emiftcl_get_parameter_value -parameter WL_JITTER_SENS_TO_PERIOD]
set var(RD_TEMP_CAL_LOSS_OCT_RECAL) [expr [emiftcl_get_parameter_value -parameter RD_TEMP_CAL_LOSS_OCT_RECAL]/1000.0]
set var(RD_TEMP_CAL_LOSS_WO_OCT_RECAL) [expr [emiftcl_get_parameter_value -parameter RD_TEMP_CAL_LOSS_WO_OCT_RECAL]/1000.0]
set var(RD_CALIBRATION_LOSS_OTHER) [expr [emiftcl_get_parameter_value -parameter RD_CALIBRATION_LOSS_OTHER]/1000.0]
set var(RD_DBI_EFFECT) [expr [emiftcl_get_parameter_value -parameter RD_DBI_EFFECT]/1000.0]
set var(RD_TEMP_CAL_LOSS_WO_DLL) [expr [emiftcl_get_parameter_value -parameter RD_TEMP_CAL_LOSS_WO_DLL]/1000.0]
set var(WR_TEMP_CAL_LOSS_OCT_RECAL) [expr [emiftcl_get_parameter_value -parameter WR_TEMP_CAL_LOSS_OCT_RECAL]/1000.0]
set var(WR_TEMP_CAL_LOSS_WO_OCT_RECAL) [expr [emiftcl_get_parameter_value -parameter WR_TEMP_CAL_LOSS_WO_OCT_RECAL]/1000.0]
set var(WR_CALIBRATION_LOSS_OTHER) [expr [emiftcl_get_parameter_value -parameter WR_CALIBRATION_LOSS_OTHER]/1000.0]
set var(CA_TEMP_CAL_LOSS_OCT_RECAL_CA_CAL) [expr [emiftcl_get_parameter_value -parameter CA_TEMP_CAL_LOSS_OCT_RECAL_CA_CAL]/1000.0]
set var(CA_TEMP_CAL_LOSS_WO_OCT_RECAL_CA_CAL) [expr [emiftcl_get_parameter_value -parameter CA_TEMP_CAL_LOSS_WO_OCT_RECAL_CA_CAL]/1000.0]
set var(CA_TEMP_CAL_LOSS_OCT_RECAL_WO_CA_CAL) [expr [emiftcl_get_parameter_value -parameter CA_TEMP_CAL_LOSS_OCT_RECAL_WO_CA_CAL]/1000.0]
set var(CA_TEMP_CAL_LOSS_WO_OCT_RECAL_WO_CA_CAL) [expr [emiftcl_get_parameter_value -parameter CA_TEMP_CAL_LOSS_WO_OCT_RECAL_WO_CA_CAL]/1000.0]
set var(CA_CALIBRATION_LOSS_OTHER) [expr [emiftcl_get_parameter_value -parameter CA_CALIBRATION_LOSS_OTHER]/1000.0]
set var(WL_TEMP_CAL_LOSS_OCT_RECAL) [expr [emiftcl_get_parameter_value -parameter WL_TEMP_CAL_LOSS_OCT_RECAL]/1000.0]
set var(WL_TEMP_CAL_LOSS_WO_OCT_RECAL) [expr [emiftcl_get_parameter_value -parameter WL_TEMP_CAL_LOSS_WO_OCT_RECAL]/1000.0]
set var(WL_TEMP_CAL_LOSS_OCT_RECAL_WO_WL_CAL) [expr [emiftcl_get_parameter_value -parameter WL_TEMP_CAL_LOSS_OCT_RECAL_WO_WL_CAL]/1000.0]
set var(WL_TEMP_CAL_LOSS_WO_OCT_RECAL_WO_WL_CAL) [expr [emiftcl_get_parameter_value -parameter WL_TEMP_CAL_LOSS_WO_OCT_RECAL_WO_WL_CAL]/1000.0]
set var(WL_CALIBRATION_LOSS_OTHER) [expr [emiftcl_get_parameter_value -parameter WL_CALIBRATION_LOSS_OTHER]/1000.0]
set var(RD_DBI_EFFECT) [expr [emiftcl_get_parameter_value -parameter RD_DBI_EFFECT]/1000.0]
set var(TERMINATION_LOSS_DEVICE_60) [expr [emiftcl_get_parameter_value -parameter TERMINATION_LOSS_DEVICE_60]/1000.0]
set var(TERMINATION_LOSS_DIMM_60) [expr [emiftcl_get_parameter_value -parameter TERMINATION_LOSS_DIMM_60]/1000.0]
set var(TERMINATION_LOSS_DEVICE_120) [expr [emiftcl_get_parameter_value -parameter TERMINATION_LOSS_DEVICE_120]/1000.0]
set var(TERMINATION_LOSS_DIMM_120) [expr [emiftcl_get_parameter_value -parameter TERMINATION_LOSS_DIMM_120]/1000.0]
set var(RD_SSI) [expr [emiftcl_get_parameter_value -parameter RD_SSI]/1000.0]
set var(RD_JITTER) [expr [emiftcl_get_parameter_value -parameter RD_JITTER]/1000.0]
set var(RD_DCD) [expr [emiftcl_get_parameter_value -parameter RD_DCD]/1000.0]
set var(RD_SH) [expr [emiftcl_get_parameter_value -parameter RD_SH]/1000.0]
set var(RD_EOL) [expr [emiftcl_get_parameter_value -parameter RD_EOL]/1000.0]
set var(WR_SSO) [expr [emiftcl_get_parameter_value -parameter WR_SSO]/1000.0]
set var(WR_JITTER) [expr [emiftcl_get_parameter_value -parameter WR_JITTER]/1000.0]
set var(WR_DCD) [expr [emiftcl_get_parameter_value -parameter WR_DCD]/1000.0]
set var(WR_EOL) [expr [emiftcl_get_parameter_value -parameter WR_EOL]/1000.0]
set var(CA_SSO) [expr [emiftcl_get_parameter_value -parameter CA_SSO]/1000.0]
set var(CA_JITTER) [expr [emiftcl_get_parameter_value -parameter CA_JITTER]/1000.0]
set var(CA_DCD) [expr [emiftcl_get_parameter_value -parameter CA_DCD]/1000.0]
set var(CA_EOL) [expr [emiftcl_get_parameter_value -parameter CA_EOL]/1000.0]
set var(DQSG_SSI) [expr [emiftcl_get_parameter_value -parameter DQSG_SSI]/1000.0]
set var(DQSG_JITTER) [expr [emiftcl_get_parameter_value -parameter DQSG_JITTER]/1000.0]
set var(DQSG_DCD) [expr [emiftcl_get_parameter_value -parameter DQSG_DCD]/1000.0]
set var(DQSG_EOL) [expr [emiftcl_get_parameter_value -parameter DQSG_EOL]/1000.0]
set var(DQSG_CAL_UNC) [expr [emiftcl_get_parameter_value -parameter DQSG_CAL_UNC]/1000.0]
set var(DQSG_TRK_UNC) [expr [emiftcl_get_parameter_value -parameter DQSG_TRK_UNC]/1000.0]
set var(DQSG_SH) [expr [emiftcl_get_parameter_value -parameter DQSG_SH]/1000.0]
set var(WL_SSO) [expr [emiftcl_get_parameter_value -parameter WL_SSO]/1000.0]
set var(WL_JITTER) [expr [emiftcl_get_parameter_value -parameter WL_JITTER]/1000.0]
set var(WL_DCD) [expr [emiftcl_get_parameter_value -parameter WL_DCD]/1000.0]
set var(WL_EOL) [expr [emiftcl_get_parameter_value -parameter WL_EOL]/1000.0]
 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 54 top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl 41418 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set script_dir [file dirname [info script]]
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_utils.tcl"

load_package sdc_ext

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_ddr_pins { instname allpins var_array_name} {
   # We need to make a local copy of the allpins associative array
   upvar allpins pins
   upvar 1 $var_array_name var
   set debug 0

   # with the hyper-retimer, the tdb netlist may contain the full set of routing nodes, so we need
   # to search deeper
   set var(pll_inclock_search_depth) 30
   set var(pll_outclock_search_depth) 20
   set var(pll_vcoclock_search_depth) 5

   # ########################################
   #  1.0 find all of the PLL output clocks

   if {[is_fitter_in_qhd_mode]} {
      set c0_periph_clock_name "phy_clk\[1\]"
      set c1_periph_clock_name "phy_clk\[0\]"
      set vco_clock_name "phy_clk_phs\[0\]"
   } else {
      set c0_periph_clock_name "pll_lvds_clk\[0\]"
      set c1_periph_clock_name "pll_loaden\[0\]"
      set vco_clock_name "pll_vcoph\[0\]"
   }

   #  C0 output in the periphery
   set pins(pll_c0_periph_clock) [list]
   set pins(pll_c0_periph_clock_id) [get_nets -nowarn [list ${instname}|arch|arch_inst|pll_inst|${c0_periph_clock_name}  ${instname}|arch|arch_inst|pll_inst|pll_inst*LVDS_CLK0]]
   foreach_in_collection c $pins(pll_c0_periph_clock_id) {
      lappend pins(pll_c0_periph_clock) [regsub -all {\\} [get_node_info -name $c] {\\\\}]
   }
   set pins(pll_c0_periph_clock) [top_emif_0_altera_emif_arch_nf_191_bclhany_sort_duplicate_names $pins(pll_c0_periph_clock)]

   #  C1 output in the periphery
   set pins(pll_c1_periph_clock) [list]
   set pins(pll_c1_periph_clock_id) [get_nets -nowarn [list ${instname}|arch|arch_inst|pll_inst|${c1_periph_clock_name}  ${instname}|arch|arch_inst|pll_inst|pll_inst*LOADEN0]]
   foreach_in_collection c $pins(pll_c1_periph_clock_id) {
      lappend pins(pll_c1_periph_clock) [regsub -all {\\} [get_node_info -name $c] {\\\\}]
   }
   set pins(pll_c1_periph_clock) [top_emif_0_altera_emif_arch_nf_191_bclhany_sort_duplicate_names $pins(pll_c1_periph_clock)]

   #  VCO clock (used for the system clock)
   set pins(vco_clock) [list]
   set pins(vco_clock_id) [get_nets -nowarn [list ${instname}|arch|arch_inst|pll_inst|${vco_clock_name}  ${instname}|arch|arch_inst|pll_inst|pll_inst*VCOPH0]]
   foreach_in_collection c $pins(vco_clock_id) {
      lappend pins(vco_clock) [regsub -all {\\} [get_node_info -name $c] {\\\\}]
   }
   set pins(vco_clock) [top_emif_0_altera_emif_arch_nf_191_bclhany_sort_duplicate_names $pins(vco_clock)]
   set pins(pll_vco_clock) $pins(vco_clock)
   set pins(pll_phy_clock) $pins(pll_c1_periph_clock)
   set pins(pll_phy_clock_l) $pins(pll_c0_periph_clock)

   if {$debug == 1} {
     puts "VCO:           $pins(pll_vco_clock)"
     puts "PHY:           $pins(pll_phy_clock)"
     puts "PHY_L:         $pins(pll_phy_clock_l)"
     puts ""
   }

   #########################################
   # 2.0  Find the actual master core clock
   #      As it could come from another interface
   #      In master/slave configurations
   #
   # Skip this if we're in HPS mode as core clocks don't exist
   
   set pins(master_vco_clock) ""
   set pins(master_vco_clock_sec) ""
   set pins(master_core_usr_clock) ""
   set pins(master_core_usr_half_clock) ""
   set pins(master_core_usr_clock_sec) ""
   set pins(master_core_usr_half_clock_sec) ""
   set pins(master_core_afi_half_clock) ""
   set pins(master_core_afi_clock) ""
   set pins(master_core_dft_cpa_1_clock) ""
   set pins(master_cal_master_clk) ""
   set pins(master_cal_slave_clk) ""
   
   if {$var(IS_HPS)} {
      set pins(master_instname) $instname

   } else {
      set msg_list [ list ]
      
      set num_of_cpa_blocks [expr {$var(PHY_PING_PONG_EN) ? 2 : 1}]
      
      for {set cpa_idx 0} {$cpa_idx < $num_of_cpa_blocks} {incr cpa_idx} {
      
         if {$cpa_idx == 0} {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|reset_sync_pri_sdc_anchor
         } else {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|pp.reset_sync_sec_sdc_anchor
         }
      
         set core_reset_sync_clock "_UNDEFINED_PIN_"
         set core_reset_sync_clock_id [top_emif_0_altera_emif_arch_nf_191_bclhany_get_output_clock_id $sync_reset_reg "Usr clock" msg_list var]
         if {$core_reset_sync_clock_id == -1} {
            foreach {msg_type msg} $msg_list {
               post_message -type $msg_type "top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl: $msg"
            }
            post_message -type error "top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl: Failed to find clock source for register $sync_reset_reg"
            
            if {$var(PHY_CORE_CLKS_SHARING_ENUM) == "CORE_CLKS_SHARING_SLAVE"} {
               post_message -type error "top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl: This is a clock sharing SLAVE interface. Please ensure that the clks_sharing_master_out port of the master is connected to the clks_sharing_master_in port of the slave(s)."
               if {$cpa_idx > 0} {
                  post_message -type error "top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl: This clock sharing slave interface uses a Ping-Pong PHY and has extra clock/reset requirements. Please ensure that the master interface is also a ping-pong interface. A ping-pong interface can act as clock sharing master for both ping-pong and non-ping-pong interfaces."
               }
            } else {
               post_message -type error "top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl: Please ensure that the register has not been removed or optimized away."
            }
         } else {
            set core_reset_sync_clock [top_emif_0_altera_emif_arch_nf_191_bclhany_get_pll_clock_name $core_reset_sync_clock_id]
         }
      
         if {[regexp {(^.*)\|arch\|arch_inst\|io_tiles_wrap_inst\|io_tiles_inst\|tile_gen\[([0-9])\].tile_ctrl_inst(.*)\|pa_core_clk_out\[[0-9]\]$} $core_reset_sync_clock matched pins(master_instname) tilegen_num tile_instnum] == 1} {
            if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
               if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock)     "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock_sec) "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  }
               } else {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  }
               }
               set pins(master_core_dft_cpa_1_clock)   [expr {$var(DIAG_CPA_OUT_1_EN) ? "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]" : ""}]

            } else {
               set pins(master_core_afi_half_clock)        "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
               set pins(master_core_afi_clock)             "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
            }

            if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn"} {
               set vco_clock_name "_UNDEFINED_PIN_"
            } else {
               set vco_clock_id [top_emif_0_altera_emif_arch_nf_191_bclhany_get_vco_clk_id $core_reset_sync_clock_id var]
               set vco_clock_name [get_net_info -name [get_pin_info -net $vco_clock_id]]
            }
            if {$cpa_idx == 0} {
               set pins(master_vco_clock) $vco_clock_name
            } else {
               set pins(master_vco_clock_sec) $vco_clock_name  
            }

         } else {
            post_message -type error "top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl: Failed to find CPA outputs."
         }
      }

      if {!$var(DIAG_USE_CPA_LOCK)} {
         set pins(counter_lock_reg) $pins(master_instname)|arch|arch_inst|non_hps.core_clks_rsts_inst|counter_lock
      }

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk
      
      set var(pll_c3_cnt) [top_emif_0_altera_emif_arch_nf_191_bclhany_calculate_counter_value $var(PLL_C_CNT_HIGH_3) $var(PLL_C_CNT_LOW_3) $var(PLL_C_CNT_BYPASS_EN_3)]
      set pins(master_cal_slave_clk) "$pll_master_user_clock_base\[3\]"
      
      set var(pll_c4_cnt) [top_emif_0_altera_emif_arch_nf_191_bclhany_calculate_counter_value $var(PLL_C_CNT_HIGH_4) $var(PLL_C_CNT_LOW_4) $var(PLL_C_CNT_BYPASS_EN_4)]
      set pins(master_cal_master_clk) "$pll_master_user_clock_base\[4\]"
   }

   if {$var(PHY_USERMODE_OCT)} {
      set pins(usermode_oct_clock) "${instname}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.r_clkdiv"
      set pins(usermode_oct_gated_clock) "${instname}|arch|arch_inst|oct_inst|cal_oct.manual_oct_cal.oct_inst|altera_oct_um_fsm_i|clkena|outclk"
   } else {
      set pins(usermode_oct_clock) ""
      set pins(usermode_oct_gated_clock) ""
   }

   if {$debug == 1} {
     puts "Master VCO                       : $pins(master_vco_clock)"
     puts "Master Core USR                  : $pins(master_core_usr_clock)"
     puts "Master Core USR Half             : $pins(master_core_usr_half_clock)"
     puts "Master Core AFI                  : $pins(master_core_afi_clock)"
     puts "Master Core AFI Half             : $pins(master_core_afi_half_clock)"
     puts "Master VCO (SECONDARY)           : $pins(master_vco_clock_sec)"
     puts "Master Core USR (SECONDARY)      : $pins(master_core_usr_clock_sec)"
     puts "Master Core USR Half (SECONDARY) : $pins(master_core_usr_half_clock_sec)"
     puts ""
   }


   # ########################################
   #  2.5 Find the reference clock input of the PLL

   set pins(pll_cascade_in_id) [get_pins -compatibility_mode $pins(master_instname)|arch|arch_inst|pll_inst|pll_inst|pll_cascade_in]
   set pll_ref_clock_id [top_emif_0_altera_emif_arch_nf_191_bclhany_get_input_clk_id $pins(pll_cascade_in_id) var]
   if {$pll_ref_clock_id == -1} {
      post_message -type critical_warning "top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl: Failed to find PLL reference clock"
   } else {
      set pll_ref_clock [get_node_info -name $pll_ref_clock_id]
   }
   set pins(pll_ref_clock) $pll_ref_clock

   if {$debug == 1} {
     puts "REF:     $pins(pll_ref_clock)"
     puts ""
   }

   #########################################
   # 3.0  find the FPGA pins

   # The hierarchy paths to all the pins are stored in the *_ip_parameters.tcl
   # file which is a generated file. Pins are divided into the following
   # protocol-agnostic categories. For each pin category, we need to
   # fully-resolve the hierarchy path patterns and store the results into
   # the "pins" arrays.
   set pin_categories [list ac_clk \
                            ac_clk_n \
                            ac_sync \
                            ac_async \
                            rclk \
                            rclk_n \
                            wclk \
                            wclk_n \
                            rdata \
                            wdata \
                            dm \
                            dbi ]

   set patterns [ list ]
   foreach pin_category $pin_categories {
      set pins($pin_category) [list]

      foreach pattern $var(PATTERNS_[string toupper $pin_category]) {
         set pattern "${instname}|$pattern"
         lappend patterns $pin_category $pattern
      }
   }

   foreach {pin_type pattern} $patterns {
      if {[string match "*|o" $pattern]} {
         set local_pins [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_names_in_collection [ get_fanouts $pattern ] ]
      } else {
         set local_pins [ top_emif_0_altera_emif_arch_nf_191_bclhany_get_names_in_collection [ get_fanins $pattern ] ]
      }

      if {[llength $local_pins] == 0} {
         post_message -type critical_warning "Could not find pin of type $pin_type from pattern $pattern"
      } else {
         foreach pin [lsort -unique $local_pins] {
            lappend pins($pin_type) $pin
         }
      }
   }

   #########################################
   # 4.0  setup extra PLL clocks parameters

   # User can use remaining PLL clocks from EMIF GUI and this is to
   # setup the parameters for those clocks such as multiply_by
   # and divide_by

   if {$var(PLL_NUM_OF_EXTRA_CLKS) > 0} {

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk

      set var(pll_num_of_reserved_cnts) 5

      for {set i 0} {$i < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i} {
         set i_cnt_num [expr $i + $var(pll_num_of_reserved_cnts)]
         set var(pll_c${i_cnt_num}_cnt) [top_emif_0_altera_emif_arch_nf_191_bclhany_calculate_counter_value $var(PLL_C_CNT_HIGH_${i_cnt_num}) $var(PLL_C_CNT_LOW_${i_cnt_num}) $var(PLL_C_CNT_BYPASS_EN_${i_cnt_num})]
         set pins(pll_extra_clk_${i}) "$pll_master_user_clock_base\[$i_cnt_num\]"
      }
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_initialize_ddr_db { ddr_db_par var_array_name} {
   upvar $ddr_db_par local_ddr_db
   upvar 1 $var_array_name var

   global ::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename
   global ::io_only_analysis

   post_sdc_message info "Initializing DDR database for CORE $::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename"
   set instance_list [top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_instance_list $::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename]

   foreach instname $instance_list {

      if {$::io_only_analysis == 0}  {
         post_sdc_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename INSTANCE: $instname"
         top_emif_0_altera_emif_arch_nf_191_bclhany_get_ddr_pins $instname allpins var
         top_emif_0_altera_emif_arch_nf_191_bclhany_verify_ddr_pins allpins var
      }

      set local_ddr_db($instname) [ array get allpins ]
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_verify_ddr_pins { pins_par var_array_name} {

   upvar 1 $var_array_name var
   upvar $pins_par pins

   if { [ llength $pins(pll_phy_clock) ] != [ llength $pins(pll_vco_clock) ] } {
      post_message -type critical_warning "Found different amounts of the phy_clocks compared to the vco_clocks"
   }
   if {!$var(IS_HPS)} {
      if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
         if { [ llength $pins(master_core_usr_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock) ] of master_core_usr_clock when there should be 1"
         }

         if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
            if { [ llength $pins(master_core_usr_half_clock) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock) ] of master_core_usr_half_clock when there should be 1"
            }
         }
         
         if {$var(PHY_PING_PONG_EN)} {
            if { [ llength $pins(master_core_usr_clock_sec) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock_sec) ] of master_core_usr_clock_sec when there should be 1"
            }

            if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
               if { [ llength $pins(master_core_usr_half_clock_sec) ] != 1 } {
                  post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock_sec) ] of master_core_usr_half_clock_sec when there should be 1"
               }
            }
         }
      } else {
         if { [ llength $pins(master_core_afi_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_afi_clock) ] of master_core_afi_clock when there should be 1"
         }
         if { [ llength $pins(master_core_afi_half_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_afi_half_clock) ] of master_core_afi_half_clock when there should be 1"
         }
      }
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_all_instances_dqs_pins { ddr_db_par } {
   upvar $ddr_db_par local_ddr_db

   set dqs_pins [ list ]
   set instnames [ array names local_ddr_db ]
   foreach instance $instnames {
      array set pins $local_ddr_db($instance)

      foreach { dqs_pin } $pins(dqs_pins) {
         lappend dqs_pins ${dqs_pin}_IN
         lappend dqs_pins ${dqs_pin}_OUT
      }
      foreach { dqsn_pin } $pins(dqsn_pins) {
         lappend dqs_pins ${dqsn_pin}_OUT
      }
      foreach { ck_pin } $pins(ck_pins) {
         lappend dqs_pins $ck_pin
      }
   }

   return $dqs_pins
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_calculate_counter_value { cnt_hi cnt_lo cnt_bypass } {
   if {$cnt_bypass} {
      set result 1
   } else {
      set result [expr {$cnt_hi + $cnt_lo}]
   }
   return $result
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_input_clk_id { pll_inclk_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_fanin_up_to_depth $pll_inclk_id top_emif_0_altera_emif_arch_nf_191_bclhany_is_node_type_pin clock results_array $var(pll_inclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find PLL clock for [get_node_info -name $pll_inclk_id]"
      set result -1
   }

   return $result
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_output_clock_id { pin_list pin_type msg_list_name var_array_name} {
   upvar 1 $msg_list_name msg_list
   upvar 1 $var_array_name var
   set output_clock_id -1

   set output_id_list [list]
   set pin_collection [get_keepers -no_duplicates $pin_list]
   if {[get_collection_size $pin_collection] == [llength $pin_list]} {
      foreach_in_collection id $pin_collection {
         lappend output_id_list $id
      }
   } elseif {[get_collection_size $pin_collection] == 0} {
      lappend msg_list "warning" "Could not find any $pin_type pins"
   } else {
      lappend msg_list "warning" "Could not find all $pin_type pins"
   }
   top_emif_0_altera_emif_arch_nf_191_bclhany_get_pll_clock $output_id_list $pin_type output_clock_id $var(pll_outclock_search_depth)
   return $output_clock_id
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_pll_clock { dest_id_list node_type clock_id_name search_depth} {
   if {$clock_id_name != ""} {
      upvar 1 $clock_id_name clock_id
   }
   set clock_id -1

   array set clk_array [list]
   foreach node_id $dest_id_list {
      top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_fanin_up_to_depth $node_id top_emif_0_altera_emif_arch_nf_191_bclhany_is_node_type_pll_clk clock clk_array $search_depth
   }
   if {[array size clk_array] == 1} {
      set clock_id [lindex [array names clk_array] 0]
      set clk [get_node_info -name $clock_id]
   } elseif {[array size clk_array] > 1} {
      puts "Found more than 1 clock driving the $node_type"
      set clk ""
   } else {
      set clk ""
   }

   return $clk
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_vco_clk_id { wf_clock_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_fanin_up_to_depth $wf_clock_id top_emif_0_altera_emif_arch_nf_191_bclhany_is_node_type_vco clock results_array $var(pll_vcoclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find VCO clock for [get_node_info -name $wf_clock_id]"
      set result -1
   }

   return $result
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_is_node_type_pll_clk { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if  {[regexp {pll_inst~.*OUTCLK[0-9]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } elseif {$atom_type == "TILE_CTRL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {tile_ctrl_inst.*\|pa_core_clk_out\[[0-9]\]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_is_node_type_vco { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {pll_inst.*\|.*vcoph\[0\]$} $node_name]} {
            set result 1
         } elseif {[regexp {pll_inst.*VCOPH0$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_does_ref_clk_exist { ref_clk_name } {

   set ref_clock_found 0
   foreach_in_collection iclk [get_clocks -nowarn] {
      set clk_targets [get_clock_info -target $iclk]
      foreach_in_collection itgt $clk_targets {
         set node_name [get_node_info -name $itgt]
         if {[string compare $node_name $ref_clk_name] == 0} {
            set ref_clock_found 1
            break
         }
      }
      if {$ref_clock_found == 1} {
         break;
      }
   }

   return $ref_clock_found
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_p2c_c2p_clock_uncertainty { instname var_array_name } {

   set success 1
   set error_message ""
   set clock_uncertainty 0
   set debug 0

   package require ::quartus::atoms
   upvar 1 $var_array_name var

   catch {read_atom_netlist} read_atom_netlist_out
   set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]

   if {$read_atom_netlist_error == 0} {
      if {[top_emif_0_altera_emif_arch_nf_191_bclhany_are_entity_names_on]} {
         regsub -all {\|} $instname "|*:" instname
      }
      regsub -all {\\} $instname {\\\\} instname
      regsub -all {\[} $instname "\\\[" instname
      regsub -all {\]} $instname "\\\]" instname

      # Find the IOPLLs
      if {$success == 1} {
         if {[top_emif_0_altera_emif_arch_nf_191_bclhany_are_entity_names_on]} {
            set pll_atoms [get_atom_nodes -matching *${instname}|*:arch|*:arch_inst|*:pll_inst|* -type IOPLL]
         } else {
            set pll_atoms [get_atom_nodes -matching *${instname}|arch|arch_inst|pll_inst|* -type IOPLL]
         }
         set num_pll_inst [get_collection_size $pll_atoms]

         if {$num_pll_inst == 0} {
            set success 0
            post_message -type critical_warning "The auto-constraining script was not able to detect any PLLs in the < $instname > memory interface."
         }
      }

      # Get atom parameters
      if {$success == 1} {

         set mcnt_list [list]
         set bw_list   [list]
         set cp_setting_list [list]
         set vco_period_list [list]

         foreach_in_collection pll_atom $pll_atoms {

            # M-counter value
            if {[get_atom_node_info -node $pll_atom -key  BOOL_IOPLL_M_CNT_BYPASS_EN] == 1} {
               set mcnt 1
            } else {
               set mcnt [expr [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_CNT_HI_DIV] + [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_CNT_LO_DIV]]
            }
            lappend mcnt_list $mcnt

            # BW
            set bw [get_atom_node_info -node $pll_atom -key  ENUM_PLL_BANDWIDTH_SELECT]
            if {[string compare -nocase $bw "AUTO"] == 0} {
               set bw "LOW"
            }
            lappend bw_list $bw

            # CP current setting
            set cp_setting [get_atom_node_info -node $pll_atom -key ENUM_IOPLL_PLL_CP_CURRENT]
            lappend cp_setting_list $cp_setting

            # VCO frequency setting
            set vco_period [get_atom_node_info -node $pll_atom -key TIME_VCO_FREQUENCY]
            lappend vco_period_list $vco_period
         }

         # Make sure all IOPLL parameters are the same
         for {set i [expr [llength $mcnt_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            if {[lindex $mcnt_list $i] != [lindex $mcnt_list [expr $i - 1]]} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $bw_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set bw_a [lindex $bw_list $i]
            set bw_b [lindex $bw_list [expr $i - 1]]
            if {[string compare -nocase $bw_a $bw_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $cp_setting_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set cp_a [lindex $cp_setting_list $i]
            set cp_b [lindex $cp_setting_list [expr $i - 1]]
            if {[string compare -nocase $cp_a $cp_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $vco_period_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set vco_a [lindex $vco_period_list $i]
            set vco_b [lindex $vco_period_list [expr $i - 1]]
            if {[string compare -nocase $vco_a $vco_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
      }

      # Calculate clock uncertainty
      if {$success == 1} {

         set mcnt [lindex $mcnt_list 0]
         set bw   [string toupper [lindex $bw_list 0]]
         set cp_setting [lindex $cp_setting_list 0]
         set cp_current [top_emif_0_altera_emif_arch_nf_191_bclhany_get_cp_current_from_setting $cp_setting]
         set vco_period [lindex $vco_period_list 0]
         if {[regexp {([0-9]+) ps} $vco_period matched vco_period] == 1} {
         } else {
            post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
            set success 0
         }

         if {$debug} {
            puts "MCNT : $mcnt"
            puts "BW   : $bw"
            puts "CP   : $cp_setting ($cp_current)"
            puts "VCO  : $vco_period"
         }

         # For VCO frequencies of > 600MHz (period < 1667ps) use the normal way of getting PLL clk uncertaint parameters
         if {$vco_period <= 1667} {
            set HFR  [get_clock_uncertainty_data NOM NOM NOM PLL OFFSET${mcnt} HFR $bw]
            set LFD  [get_clock_uncertainty_data NOM NOM NOM PLL OFFSET${mcnt} LFD $bw]
            set SPE  [top_emif_0_altera_emif_arch_nf_191_bclhany_get_spe_from_cp_current $cp_current]

         } elseif {
           ($vco_period > 3572) ||                                       
           ([string compare -nocase $bw "HIGH"] != 0) ||                 
           ($mcnt < 2) ||                                                
           (($mcnt > 8) && ($vco_period > 2500))                         
           } {

            post_message -type critical_warning "The PLL parameters are out of range."
            set HFR  1000e-12
            set LFD  1000e-12
            set SPE  1000e-12
            set success 0

         } else {
            set clk_uncertainty_params [top_emif_0_altera_emif_arch_nf_191_bclhany_get_alternate_clock_uncertainty_parameters $mcnt $bw $cp_current $vco_period]
            set HFR  [lindex $clk_uncertainty_params 0]
            set LFD  [lindex $clk_uncertainty_params 1]
            set SPE  [lindex $clk_uncertainty_params 2]
         }

         if {$success == 1} {
            set clock_uncertainty_sqrt  [expr sqrt(($LFD/2)*($LFD/2) + ($LFD/2)*($LFD/2))]
            set clock_uncertainty [top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [expr ($clock_uncertainty_sqrt + $SPE)*1e9]]

            if {$debug} {
               puts "HFR  : $HFR"
               puts "LFD  : $LFD"
               puts "SPE  : $SPE"
               puts "TOTAL: $clock_uncertainty"
            }
         }
      }

   } else {
      set success 0
      post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
   }

   # Output warning in the case that clock uncertainty can't be determined
   if {$success == 0} {
      post_message -type critical_warning "Verify the following:"
      post_message -type critical_warning " The core < $instname > is instantiated within another component (wrapper)"
      post_message -type critical_warning " The core is not the top-level of the project"
      post_message -type critical_warning " The memory interface pins are exported to the top-level of the project"
      post_message -type critical_warning " The core  < $instname > RTL has not been modified manually"
   }

   return $clock_uncertainty
}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_cp_current_from_setting { cp_setting } {

   set cp_current 0

   if {[string compare -nocase $cp_setting "PLL_CP_SETTING8"] == 0} {
      set cp_current 10
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING10"] == 0} {
      set cp_current 20
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING12"] == 0} {
      set cp_current 40
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING14"] == 0} {
      set cp_current 15
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING15"] == 0} {
      set cp_current 30
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING21"] == 0} {
      set cp_current 25
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING28"] == 0} {
      set cp_current 35
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING35"] == 0} {
      set cp_current 45
   } else {
      set cp_current 0
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_spe_from_cp_current { cp_current } {

   set spe 147.0e-12

   if {$cp_current <= 15} {
      set spe 147.0e-12
   } elseif {$cp_current <= 20} {
      set spe 117.0e-12
   } elseif {$cp_current <= 25} {
      set spe 87.0e-12
   } elseif {$cp_current <= 30} {
      set spe 75.0e-12
   } elseif {$cp_current <= 35} {
      set spe 60.0e-12
   } elseif {$cp_current <= 40} {
      set spe 55.0e-12
   } elseif {$cp_current <= 45} {
      set spe 49.0e-12
   } else {
      set spe 49.0e-12
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_odv_reduction_factor {master_pll_location inst phyclk_name} {

   set odv_reduction_factor 0.0
   set debug 0

   set phy_clocks [get_clocks $phyclk_name]
   foreach_in_collection c $phy_clocks { set phy_clock_targets [get_clock_info -targets $c] }
   foreach_in_collection p $phy_clock_targets { set pll_cell [get_node_info -cell $p] }
   set pll_location [get_cell_info -location $pll_cell]

   if {[regexp {IOPLL_X([0-9]+)_Y([0-9]+)_N([0-9]+)$} $master_pll_location matched master_x master_y master_n] == 1} {
      if {[regexp {IOPLL_X([0-9]+)_Y([0-9]+)_N([0-9]+)$} $pll_location matched x y n] == 1} {

      if {$master_x == $x} {

         if {$master_y == $y} {
            set odv_reduction_factor 0.0
         } else {
            set y_distance [expr abs($master_y - $y)]
            set y_distance_tiles [expr $y_distance / 27]

            set odv_reduction_factor 0
            if {$odv_reduction_factor < 0} {
               set odv_reduction_factor 0.0
            }
         }

         if {$debug == 1} {
            puts "$master_pll_location $pll_location $y_distance $y_distance_tiles $odv_reduction_factor"
         }

      } else {
         set odv_reduction_factor 0.0
       }
     } else {
        set odv_reduction_factor 0.0
     }
   } else {
      set odv_reduction_factor 0.0
   }

   return $odv_reduction_factor
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_a10_iopll_workaround_present {} {
   set oscs [get_pins -nowarn -compatibility_mode *ALTERA_INSERTED_OSCILLATOR_FOR_IOPLL\|clkout]
   set num_oscs 0
   foreach_in_collection o $oscs {
      incr num_oscs
   }
   if {$num_oscs > 0} {
      return true
   } else {
      return false
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_periphery_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set speed_temp_grade [get_speedgrade_name]

   set c2p_setup  [top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [expr [get_clock_uncertainty_data 900MV $speed_temp_grade EMIF SETUP C2P]*1e9 + ($var(PHY_REF_CLK_JITTER_PS) - 10.0)/1000.0]]
   set c2p_hold   [top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [expr [get_clock_uncertainty_data 900MV $speed_temp_grade EMIF HOLD C2P]*1e9  + ($var(PHY_REF_CLK_JITTER_PS) - 10.0)/1000.0]]
   set p2c_setup  [top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [expr [get_clock_uncertainty_data 900MV $speed_temp_grade EMIF SETUP P2C]*1e9 + ($var(PHY_REF_CLK_JITTER_PS) - 10.0)/1000.0]]
   set p2c_hold   [top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp [expr [get_clock_uncertainty_data 900MV $speed_temp_grade EMIF HOLD P2C]*1e9  + ($var(PHY_REF_CLK_JITTER_PS) - 10.0)/1000.0]]
   
   if {[top_emif_0_altera_emif_arch_nf_191_bclhany_get_a10_iopll_workaround_present]} {
      set c2p_setup   [expr $c2p_setup + 0.004]
      set c2p_hold    [expr $c2p_hold  + 0.004]
      set p2c_setup   [expr $p2c_setup + 0.004]
      set p2c_hold    [expr $p2c_hold  + 0.004]
   }

   set results [list $c2p_setup $c2p_hold $p2c_setup $p2c_hold]
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set c2c_same_setup  0
   set c2c_same_hold   0
   set c2c_diff_setup  0
   set c2c_diff_hold   0

   set results [list $c2c_same_setup $c2c_same_hold $c2c_diff_setup $c2c_diff_hold]
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_overconstraints { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set speed_temp_grade [get_speedgrade_name]

   set results [list $var(C2C_SAME_CLK_SETUP_OC_NS) $var(C2C_SAME_CLK_HOLD_OC_NS) $var(C2C_DIFF_CLK_SETUP_OC_NS) $var(C2C_DIFF_CLK_HOLD_OC_NS)]
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_periphery_overconstraints { results_st_array_name results_mt_array_name var_array_name } {
   upvar 1 $results_st_array_name results_st
   upvar 1 $results_mt_array_name results_mt
   upvar 1 $var_array_name var

   set c2p_p2c_frequency [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(C2P_P2C_CLK_RATIO)]

   set results_st [list $var(C2P_SETUP_OC_NS) $var(C2P_HOLD_OC_NS) $var(P2C_SETUP_OC_NS) $var(P2C_HOLD_OC_NS)]
   set results_mt [list [expr $var(C2P_SETUP_OC_NS) + 0.000] [expr $var(C2P_HOLD_OC_NS) + 0.000] [expr $var(P2C_SETUP_OC_NS) + 0.000] [expr $var(P2C_HOLD_OC_NS) + 0.000]]

}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_sort_duplicate_names { names_array } {

   set main_name ""
   set duplicate_names [list]

   # Find the main name as opposed to all the duplicate names
   foreach { name } $names_array {
      if  {[regexp {Duplicate} $name]} {
         lappend duplicate_names $name
      } else {
         if {$main_name == ""} {
            set main_name $name
         } else {
            post_message -type error "More than one main tile name ($main_name and $name).  Please verify the connectivity of these pins."
         }
      }
   }

   # Now sort the duplicate names
   set duplicate_names [lsort -decreasing $duplicate_names]

   # Prepend the main name and then return
   set result [join [linsert $duplicate_names 0 $main_name]]

   return $result
}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_alternate_clock_uncertainty_parameters { mcnt bw cp_current vco_period } {

    set success 1

    if {($vco_period <= 1667) || ($vco_period > 3572) || ([string compare -nocase $bw "HIGH"] != 0) || ($mcnt < 2)} {
    
        post_message -type error "PLL parameters are inappropriate for this function to be called."
        set success 0
    
    # For VCO frequencies between 400MHz and 600MHz
    } elseif {$vco_period <= 2500} {

        if {$mcnt == 2} {
            set HFR 171e-12
            set LFD 213e-12
        } elseif {$mcnt == 3} {
            set HFR 159e-12
            set LFD 206e-12
        } elseif {$mcnt == 4} {
            set HFR 158e-12
            set LFD 137e-12
        } elseif {$mcnt == 5} {
            set HFR 175e-12
            set LFD 240e-12
        } elseif {$mcnt == 6} {
            set HFR 183e-12
            set LFD 219e-12
        } elseif {$mcnt == 7} {
            set HFR 190e-12
            set LFD 232e-12
        } elseif {$mcnt == 8} {
            set HFR 158e-12
            set LFD 174e-12
        } elseif {$mcnt == 9} {
            set HFR 202e-12
            set LFD 225e-12
        } elseif {$mcnt <= 15} {
            set HFR 236e-12
            set LFD 264e-12
        } else {
            post_message -type critical_warning "PLL parameters are inappropriate for this function to be called."
            set success 0
        }

    # For VCO frequencies between 280MHz and 400MHz
    } else {
        if {$mcnt == 2} {
            set HFR 120e-12
            set LFD 133e-12
        } elseif {$mcnt == 3} {
            set HFR 207e-12
            set LFD 257e-12
        } elseif {$mcnt == 4} {
            set HFR 139e-12
            set LFD 127e-12
        } elseif {$mcnt == 5} {
            set HFR 234e-12
            set LFD 304e-12
        } elseif {$mcnt == 6} {
            set HFR 248e-12
            set LFD 276e-12
        } elseif {$mcnt == 7} {
            set HFR 259e-12
            set LFD 293e-12
        } elseif {$mcnt == 8} {
            set HFR 287e-12
            set LFD 241e-12
        } else {
            post_message -type critical_warning "PLL parameters are inappropriate for this function to be called."
            set success 0
        }
    }

    set SPE  [expr [top_emif_0_altera_emif_arch_nf_191_bclhany_get_spe_from_cp_current $cp_current] + 25e-12]

    if {$success == 0} {
        set HFR  1000e-12
        set LFD  1000e-12
        set SPE  1000e-12
    }
    
    set return_value [list $HFR $LFD $SPE]
    return $return_value
}
 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 63 top_emif_0_altera_emif_arch_nf_191_bclhany_report_io_timing.tcl 9780 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the early external memory
# interface timing report at the before the start of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determin if only doing IO analysis
set ::io_only_analysis 1

#############################################################
# Initialize the environment / Error Checking
#############################################################

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
      set project_name [lindex $quartus(args) 0]
      project_open -revision [ get_current_revision $project_name ] $project_name
   } else {
      post_message -type error "Missing project_name argument"
      return 1
   }
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   # In IO only flow, check to see if we could even create a timing nelist
   # First try to see if we could even create a
   catch {create_timing_netlist} create_timing_netlist_out
   set create_timing_netlist_error [regexp "ERROR" $create_timing_netlist_out]
      
   # If create timing netlist cannot run, then the IO flow is a valid flow
   if {$create_timing_netlist_error == 1} {
      create_emif_netlist -revision $::quartus(project)
      sta_create_empty_report   
   } else {
      delete_timing_netlist
      post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
      return 1   
   }

} else {
   post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
   return 1
}

# Load the reports
load_package report
catch {load_report} load_report_out
set report_not_loaded [regexp "ERROR" $load_report_out]
if {$report_not_loaded == 1} {
   create_report_database -type cmp
   create_report_database -type taw
}

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_ip_parameters.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_parameters.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_report_timing_core.tcl"


if [ info exists ddr_db ] {
   unset ddr_db
}
top_emif_0_altera_emif_arch_nf_191_bclhany_initialize_ddr_db ddr_db var


# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename}"
   } else {
      set fbasename "${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename}_${inst_id}"
   }
   
   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname "All conditions"
   set opcname [string trim $opcname]
   
   #######################################
   # Read Analysis

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_read_capture_analysis $opcname $inst pins var summary
   
   #######################################
   # Write Analysis

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_write_launch_analysis $opcname $inst pins var summary

   #######################################
   # Address/command Analyses

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_ac_analysis  $opcname $inst pins var summary

   #######################################
   # DQS Gating Analysis

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_dqs_gating_analysis   $opcname $inst pins var summary

   #######################################
   # Write Levelling Analysis 
   
   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_write_levelling_analysis $opcname $inst pins var summary

   #######################################
   # PHY Analyses
   
   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_core_analysis $opcname $inst pins var summary

   #######################################
   # Print out the Summary Panel for this instance   

   set summary [lsort -command top_emif_0_altera_emif_arch_nf_191_bclhany_sort_proc $summary]

   set f -1
   set fname "${fbasename}_io_summary.csv"

   set f [open $fname w]

   puts $f "Core: ${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename} - Instance: $inst"
   puts $f "Path, Setup Margin, Hold Margin"

   
   post_message -type info "Core: ${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename} - Instance: $inst"
   post_message -type info "                                                         setup  hold"
   set panel_name "$inst"
   set root_folder_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_current_timequest_report_folder]
   
   if { ! [string match "${root_folder_name}*" $panel_name] } {
      set panel_name "${root_folder_name}||$panel_name"
   }
   # Create the root if it doesn't yet exist
   if {[get_report_panel_id $root_folder_name] == -1} {
      set panel_id [create_report_panel -folder $root_folder_name]
   }
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }


      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
         set type warning
         set offset 50
      } else {
         set type info
         set offset 53
      }
      if {$su != "--"} {
         set su [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      puts $f [format "\"%s\",%s,%s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   close $f
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }
   
   incr inst_id
}
# end foreach inst


if {$report_not_loaded == 1} {
   save_report_database
   sta_reload_sta_report
}

delete_emiftcl
 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 60 top_emif_0_altera_emif_arch_nf_191_bclhany_report_timing.tcl 10739 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the external memory
# interface timing report at the end of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determin if only doing IO analysis
set ::io_only_analysis 0

#############################################################
# Initialize the environment / Error Checking
#############################################################

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
		set project_name [lindex $quartus(args) 0]
		project_open -revision [ get_current_revision $project_name ] $project_name
	} else {
		post_message -type error "Missing project_name argument"
		return 1
	}
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   create_timing_netlist
   read_sdc
   update_timing_netlist

   set script_dir [file dirname [info script]]
   source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_ip_parameters.tcl"
   source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_parameters.tcl"
   source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl"
   source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_report_timing_core.tcl"
   if { ! [timing_netlist_exist] } {
      post_message -type error "Timing Netlist has not been created. Run the 'Update Timing Netlist' task first."
      return 1
   }
}


# Load the atom netlist if required
load_package atoms
read_atom_netlist

# Load the reports
load_package report
load_report

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_ip_parameters.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_parameters.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_pin_map.tcl"
source "$script_dir/top_emif_0_altera_emif_arch_nf_191_bclhany_report_timing_core.tcl"

###############################################
# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to timing analyze the Core.

if [ info exists ddr_db ] {
   unset ddr_db
}
top_emif_0_altera_emif_arch_nf_191_bclhany_initialize_ddr_db ddr_db var

set old_active_clocks [get_active_clocks]
set_active_clocks [all_clocks]

# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename}"
   } else {
      set fbasename "${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename}_${inst_id}"
   }
   
   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname [get_operating_conditions_info [get_operating_conditions] -display_name]
   set opcname [string trim $opcname]

   #######################################
   # Read Analysis

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_read_capture_analysis $opcname $inst pins var summary
   
   #######################################
   # Write Analysis

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_write_launch_analysis $opcname $inst pins var summary

   #######################################
   # Address/command Analyses

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_ac_analysis  $opcname $inst pins var summary

   #######################################
   # DQS Gating Analysis

   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_dqs_gating_analysis   $opcname $inst pins var summary

   #######################################
   # Write Levelling Analysis 
   
   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_write_levelling_analysis $opcname $inst pins var summary

   #######################################
   # Analyses related to FPGA core
   
   top_emif_0_altera_emif_arch_nf_191_bclhany_perform_core_analysis $opcname $inst pins var summary

   #######################################
   # Print out the Summary Panel for this instance   

   set summary [lsort -command top_emif_0_altera_emif_arch_nf_191_bclhany_sort_proc $summary]

   set f -1
   set fname "${fbasename}_summary.csv"

   if { [top_emif_0_altera_emif_arch_nf_191_bclhany_get_operating_conditions_number] == 0 } {
      set f [open $fname w]

      puts $f "Core: ${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename} - Instance: $inst"
      puts $f "Path, Setup Margin, Hold Margin"
   } else {
      set f [open $fname a]
   }

   
   post_message -type info "Core: ${::GLOBAL_top_emif_0_altera_emif_arch_nf_191_bclhany_corename} - Instance: $inst"
   post_message -type info "                                                               setup  hold"
   set panel_name "$inst"
   set root_folder_name [get_current_timequest_report_folder]
   if { ! [string match "${root_folder_name}*" $panel_name] } {
      set panel_name "${root_folder_name}||$panel_name"
   }
   # Create the root if it doesn't yet exist
   if {[get_report_panel_id $root_folder_name] == -1} {
      set panel_id [create_report_panel -folder $root_folder_name]
   }
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }

      set type info
      set offset 59
      
      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
      }
      if {$su != "--"} {
         set su [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      puts $f [format "\"%s\",%s,%s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   close $f
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }
   
   incr inst_id
}
# end foreach inst


set_active_clocks $old_active_clocks

set curr_part $::TimeQuestInfo(part)
set curr_speedgrade [string range $curr_part 12 13]

if {![test_part_trait_of $curr_part -trait FINAL_TIMING_MODEL]} {
   post_message -type critical_warning "Timing analysis was performed using a non-final timing model and/or constraints. You must regenerate the external memory interface IP and recheck timing closure in a future version of Quartus Prime."
}

if {$var(PHY_TARGET_SPEEDGRADE) == ""} {
   set effective_target_speedgrade "E1"
} else {
   set effective_target_speedgrade $var(PHY_TARGET_SPEEDGRADE)
}

if {$curr_speedgrade != $effective_target_speedgrade} {
   post_message -type critical_warning "This External Memory Interface IP core was generated for a speed grade $effective_target_speedgrade device, but the speed grade of $curr_part is $curr_speedgrade. You should regenerate the IP core to match the target device to avoid hardware issue."
}

write_timing_report
delete_emiftcl
 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 65 top_emif_0_altera_emif_arch_nf_191_bclhany_report_timing_core.tcl 41323 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#############################################################
# Read Timing Analysis
#############################################################
proc top_emif_0_altera_emif_arch_nf_191_bclhany_perform_read_capture_analysis {opcname inst pin_array_name var_array_name summary_name} {

   set analysis_name "Read Capture"

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0   
   set result 1

   ###############################
   # Write summary report
   ###############################

   set positive_fcolour [list "black" "blue"]
   set negative_fcolour [list "black" "red" ]

   set summary [list]
   
   set var(RD_UI) [expr $var(UI)/2]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_UI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_UI)]]

   set var(RD_ISI) $var(RD_ISI)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_ISI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_ISI)]]

   set var(RD_SSI) $var(RD_SSI)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_SSI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_SSI)]]

   set var(RD_DQSQ) [expr $var(tDQSQ)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_DQSQ]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_DQSQ)]]

   set var(RD_QH) [expr (1-$var(tQH)*2)*$var(tCK)/2]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_QH]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_QH)]]

   set var(RD_MPR) [expr ($var(WITH_MPR) == 1 ? -$var(RD_DQSQ)*$var(MPR_DQSQ)-$var(RD_QH)*$var(MPR_QH) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_MPR]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_MPR)]]

   set var(RD_JITTER) $var(RD_JITTER)
   set var(RD_JITTER_sens) [expr ([expr (($var(UI))*1000.0-$var(EXTRACTED_PERIOD))*$var(RD_JITTER_SENS_TO_PERIOD)])/1000.0]
   if {$var(RD_JITTER_sens) > 0} {
      set var(RD_JITTER) [expr $var(RD_JITTER) + $var(RD_JITTER_sens)]
   }
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_JITTER]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_JITTER)]]

   set var(RD_DCD) $var(RD_DCD)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_DCD]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_DCD)]]

   set var(RD_SH) $var(RD_SH)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_SH]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_SH)]]

   set var(RD_EOL) $var(RD_EOL)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_EOL]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_EOL)]]

   set var(RD_CAL_UNC) [expr $var(RD_CALIBRATION_LOSS_OTHER)+($var(IS_DLL_ON) == 1 ? 0 : $var(RD_TEMP_CAL_LOSS_WO_DLL))+($var(OCT_RECAL) == 1 ? $var(RD_TEMP_CAL_LOSS_OCT_RECAL) : $var(RD_TEMP_CAL_LOSS_WO_OCT_RECAL))+(([string compare $var(PROTOCOL) "DDR4"] == 0) ? ($var(RDBI) == 1 ? 0 : $var(RD_DBI_EFFECT)) : (([string compare $var(PROTOCOL) "QDRIV"] == 0) ? ($var(RDBI) == 1 ? 0 : $var(RD_DBI_EFFECT)) : 0))+($var(IS_COMPONENT) == 1 ? ($var(TERMINATION_LESS_THAN_120) == 1 ? $var(TERMINATION_LOSS_DEVICE_60) : $var(TERMINATION_LOSS_DEVICE_120)) : ($var(TERMINATION_LESS_THAN_120) == 1 ? $var(TERMINATION_LOSS_DIMM_60) : $var(TERMINATION_LOSS_DIMM_120)))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_CAL_UNC]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_CAL_UNC)]]

   set var(RD_SK_EFFECT) [expr ($var(BD_PKG_SKEW)-$var(DEFAULT_BD_PKG_SKEW))*$var(BD_SK_SENS_RD)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_SK_EFFECT]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_SK_EFFECT)]]

   set var(RD_MARGIN) [expr $var(RD_UI)-$var(RD_ISI)-$var(RD_SSI)-$var(RD_DQSQ)-$var(RD_QH)-$var(RD_MPR)-$var(RD_JITTER)-$var(RD_DCD)-$var(RD_SH)-$var(RD_EOL)-$var(RD_CAL_UNC)-$var(RD_SK_EFFECT)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter RD_MARGIN]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(RD_MARGIN)]]
   
   #######################################
   #######################################
   # Create the read analysis panel   
   
   set setup_slack [expr $var(RD_MARGIN)/2]
   set hold_slack  [expr $var(RD_MARGIN)/2]

   set panel_name "$inst $analysis_name"
   set root_folder_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_current_timequest_report_folder]
   
   if { ! [string match "${root_folder_name}*" $panel_name] } {
      set panel_name "${root_folder_name}||$panel_name"
   }
   # Create the root if it doesn't yet exist
   if {[get_report_panel_id $root_folder_name] == -1} {
      set panel_id [create_report_panel -folder $root_folder_name]
   }

   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }
   
   if {($setup_slack < 0) || ($hold_slack <0)} {
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   add_row_to_table -id $panel_id [list "Operation" "Margin"]      
   
   foreach summary_line $summary {
      add_row_to_table -id $panel_id $summary_line -fcolors $positive_fcolour
   }
   
   lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $setup_slack] [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $hold_slack]]
}


#############################################################
# Write Timing Analysis
#############################################################
proc top_emif_0_altera_emif_arch_nf_191_bclhany_perform_write_launch_analysis {opcname inst pin_array_name var_array_name summary_name} {

   set analysis_name "Write"

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0   
   set result 1

   ###############################
   # Write summary report
   ###############################

   set positive_fcolour [list "black" "blue"]
   set negative_fcolour [list "black" "red" ]

   set summary [list]
   
   set var(WR_UI) [expr $var(UI)/2]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_UI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_UI)]]

   set var(WR_ISI) $var(WR_ISI)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_ISI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_ISI)]]

   set var(WR_SSO) $var(WR_SSO)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_SSO]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_SSO)]]

   set var(WR_DS) [expr $var(tDS)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_DS]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_DS)]]

   set var(WR_DH) [expr $var(tDH)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_DH]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_DH)]]

   set var(WR_MPR) [expr ($var(WITH_MPR) == 1 ? -$var(WR_DS)*$var(MPR_DS) -$var(WR_DH)*$var(MPR_DH) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_MPR]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_MPR)]]

   set var(WR_JITTER) $var(WR_JITTER)
   set var(WR_JITTER_sens) [expr ([expr (($var(UI))*1000.0-$var(EXTRACTED_PERIOD))*$var(WR_JITTER_SENS_TO_PERIOD)])/1000.0]
   if {$var(WR_JITTER_sens) > 0} {
      set var(WR_JITTER) [expr $var(WR_JITTER) + $var(WR_JITTER_sens)]
   }
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_JITTER]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_JITTER)]]

   set var(WR_DCD) $var(WR_DCD)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_DCD]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_DCD)]]

   set var(WR_EOL) $var(WR_EOL)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_EOL]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_EOL)]]

   set var(WR_CAL_UNC) [expr $var(WR_CALIBRATION_LOSS_OTHER)+($var(OCT_RECAL) == 1 ? $var(WR_TEMP_CAL_LOSS_OCT_RECAL) : $var(WR_TEMP_CAL_LOSS_WO_OCT_RECAL))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_CAL_UNC]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_CAL_UNC)]]

   set var(WR_SK_EFFECT) [expr ($var(BD_PKG_SKEW)-$var(DEFAULT_BD_PKG_SKEW))*$var(BD_SK_SENS_WR)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_SK_EFFECT]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_SK_EFFECT)]]

   set var(WR_MARGIN) [expr $var(WR_UI)-$var(WR_ISI)-$var(WR_SSO)-$var(WR_DS)-$var(WR_DH)-$var(WR_MPR)-$var(WR_JITTER)-$var(WR_DCD)-$var(WR_EOL)-$var(WR_CAL_UNC)-$var(WR_SK_EFFECT)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WR_MARGIN]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WR_MARGIN)]]
   
   #######################################
   #######################################
   # Create the write analysis panel   
   set setup_slack [expr $var(WR_MARGIN)/2]
   set hold_slack  [expr $var(WR_MARGIN)/2]

   set panel_name "$inst $analysis_name"
   set root_folder_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_current_timequest_report_folder]
   
   if { ! [string match "${root_folder_name}*" $panel_name] } {
      set panel_name "${root_folder_name}||$panel_name"
   }
   # Create the root if it doesn't yet exist
   if {[get_report_panel_id $root_folder_name] == -1} {
      set panel_id [create_report_panel -folder $root_folder_name]
   }

   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }
   
   if {($setup_slack < 0) || ($hold_slack <0)} {
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   add_row_to_table -id $panel_id [list "Operation" "Margin"]       
   
   foreach summary_line $summary {
      add_row_to_table -id $panel_id $summary_line -fcolors $positive_fcolour
   }
   
   lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $setup_slack] [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $hold_slack]]
}

#############################################################
# Address/Command Timing Analysis
#############################################################
proc top_emif_0_altera_emif_arch_nf_191_bclhany_perform_ac_analysis {opcname inst pin_array_name var_array_name summary_name} {

   set analysis_name "Address/Command"


   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0   
   set result 1

   ###############################
   # AC summary report
   ###############################

   set positive_fcolour [list "black" "blue"]
   set negative_fcolour [list "black" "red" ]

   set summary [list]
   
   set var(AC_UI) [expr (([string compare $var(PROTOCOL) "QDRIV"] == 0) ? $var(UI)/2 : (([string compare $var(PROTOCOL) "LPDDR3"] == 0) ? $var(UI)/2 : $var(UI)))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter AC_UI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(AC_UI)]]

   set var(CA_ISI) $var(CA_ISI)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_ISI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_ISI)]]

   set var(CA_SSO) $var(CA_SSO)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_SSO]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_SSO)]]

   set var(CA_IS) [expr $var(tIS)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_IS]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_IS)]]

   set var(CA_IH) [expr $var(tIH)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_IH]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_IH)]]

   set var(CA_MPR) [expr ($var(WITH_CA_CALIB) == 1 ? ($var(NUM_RANKS) == 1 ? ($var(WITH_MPR) == 1 ? -$var(CA_IS)*$var(MPR_IS) - $var(CA_IH)*$var(MPR_IH) : 0) : 0) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_MPR]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_MPR)]]

   set var(CA_JITTER) $var(CA_JITTER)
   set var(CA_JITTER_sens) [expr ([expr (($var(UI))*1000.0-$var(EXTRACTED_PERIOD))*$var(CA_JITTER_SENS_TO_PERIOD)])/1000.0]
   if {$var(CA_JITTER_sens) > 0} {
      set var(CA_JITTER) [expr $var(CA_JITTER) + $var(CA_JITTER_sens)]
   }
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_JITTER]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_JITTER)]]

   set var(CA_DCD) $var(CA_DCD)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_DCD]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_DCD)]]

   set var(CA_EOL) $var(CA_EOL)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_EOL]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_EOL)]]

   set var(CA_CAL_UNC) [expr ($var(WITH_CA_CALIB) == 1 ? $var(CA_CALIBRATION_LOSS_OTHER)+($var(OCT_RECAL) == 1 ? $var(CA_TEMP_CAL_LOSS_OCT_RECAL_CA_CAL) : $var(CA_TEMP_CAL_LOSS_WO_OCT_RECAL_CA_CAL)) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_CAL_UNC]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_CAL_UNC)]]

   set var(CA_PVT) [expr ($var(WITH_CA_CALIB) == 1 ? 0 : $var(CA_CALIBRATION_LOSS_OTHER)+($var(OCT_RECAL) == 1 ? $var(CA_TEMP_CAL_LOSS_OCT_RECAL_WO_CA_CAL) : $var(CA_TEMP_CAL_LOSS_WO_OCT_RECAL_WO_CA_CAL)))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_PVT]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_PVT)]]

   set var(CA_SK_EFFECT) [expr ($var(WITH_CA_CALIB) == 1 ? ($var(CA_BD_PKG_SKEW)-$var(DEFAULT_BD_PKG_SKEW))*$var(BD_SK_SENS_CA) : ($var(CA_BD_PKG_SKEW)-$var(DEFAULT_BD_PKG_SKEW))*$var(BD_SK_SENS_CA_WO_CALIB)+$var(CA_BD_PKG_SKEW)+($var(CA_TO_CK_BD_PKG_SKEW) < 0 == 1 ?  -2*$var(CA_TO_CK_BD_PKG_SKEW) :  2*$var(CA_TO_CK_BD_PKG_SKEW)))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_SK_EFFECT]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_SK_EFFECT)]]

   set var(CA_MARGIN) [expr $var(AC_UI)-$var(CA_ISI)-$var(CA_SSO)-$var(CA_IS)-$var(CA_IH)-$var(CA_MPR)-$var(CA_JITTER)-$var(CA_DCD)-$var(CA_EOL)-$var(CA_CAL_UNC)-$var(CA_PVT)-$var(CA_SK_EFFECT)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter CA_MARGIN]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(CA_MARGIN)]]
   
   
   #######################################
   #######################################
   # Create the AC analysis panel   
   set setup_slack [expr $var(CA_MARGIN)/2]
   set hold_slack  [expr $var(CA_MARGIN)/2]

   set panel_name "$inst $analysis_name"
   set root_folder_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_current_timequest_report_folder]

   if { ! [string match "${root_folder_name}*" $panel_name] } {
      set panel_name "${root_folder_name}||$panel_name"
   }
   # Create the root if it doesn't yet exist
   if {[get_report_panel_id $root_folder_name] == -1} {
      set panel_id [create_report_panel -folder $root_folder_name]
   }

   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }
   
   if {($setup_slack < 0) || ($hold_slack <0)} {
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   add_row_to_table -id $panel_id [list "Operation" "Margin"]      
   
   foreach summary_line $summary {
      add_row_to_table -id $panel_id $summary_line -fcolors $positive_fcolour
   }
   
   lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $setup_slack] [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $hold_slack]]
}

#############################################################
# DQS Gating Timing Analysis
#############################################################
proc top_emif_0_altera_emif_arch_nf_191_bclhany_perform_dqs_gating_analysis  {opcname inst pin_array_name var_array_name summary_name} {

   set analysis_name "DQS Gating"

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0   
   set result 1


   # Only perform for DDR protocols 
   if { !(([string compare $var(PROTOCOL) "DDR4"] == 0) || ([string compare $var(PROTOCOL) "DDR3"] == 0) || ([string compare $var(PROTOCOL) "LPDDR3"] == 0))} {
      return
   }
   
   ###############################
   # DQS Gating summary report
   ###############################

   set positive_fcolour [list "black" "blue"]
   set negative_fcolour [list "black" "red" ]

   set summary [list]
   
   set var(DQSG_UI) [expr (([string compare $var(PROTOCOL) "DDR4"] == 0) ? ($var(X4) == 1 ? $var(UI) : 2*$var(UI)) : ((([string compare $var(PROTOCOL) "DDR3"] == 0) ? $var(UI)*0.8 : (([string compare $var(PROTOCOL) "LPDDR3"] == 0) ? $var(UI)*0.8 : $var(UI)))))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_UI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_UI)]]

   set var(DQSG_ISI) $var(DQSG_ISI)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_ISI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_ISI)]]

   set var(DQSG_SSI) $var(DQSG_SSI)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_SSI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_SSI)]]

   set var(DQSG_DQSCK) [expr (([string compare $var(PROTOCOL) "LPDDR3"] == 0) ? $var(tDQSCK) : $var(tDQSCK)*2)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_DQSCK]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_DQSCK)]]

   set var(DQSG_MPR) [expr ($var(WITH_MPR) == 1 ? -$var(DQSG_DQSCK)*$var(MPR_DQSCK) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_MPR]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_MPR)]]

   set var(DQSG_JITTER) $var(DQSG_JITTER)
   set var(DQSG_JITTER_sens) [expr ([expr (($var(UI))*1000.0-$var(EXTRACTED_PERIOD))*$var(DQSG_JITTER_SENS_TO_PERIOD)])/1000.0]
   if {$var(DQSG_JITTER_sens) > 0} {
      set var(DQSG_JITTER) [expr $var(DQSG_JITTER) + $var(DQSG_JITTER_sens)]
   }
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_JITTER]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_JITTER)]]

   set var(DQSG_DCD) $var(DQSG_DCD)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_DCD]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_DCD)]]

   set var(DQSG_EOL) $var(DQSG_EOL)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_EOL]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_EOL)]]

   set var(DQSG_CAL_UNC) $var(DQSG_CAL_UNC)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_CAL_UNC]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_CAL_UNC)]]

   set var(DQSG_TRK_UNC) $var(DQSG_TRK_UNC)
   set var(DQSG_TRK_UNC_sens) [expr ([expr (($var(UI))*1000.0-$var(EXTRACTED_PERIOD))*$var(DQSG_TRKUNC_SENS_TO_PERIOD)])/1000.0]
   if {$var(DQSG_TRK_UNC_sens) > 0} {
      set var(DQSG_TRK_UNC) [expr $var(DQSG_TRK_UNC) + $var(DQSG_TRK_UNC_sens)]
   }
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_TRK_UNC]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_TRK_UNC)]]

   set var(DQSG_SH) $var(DQSG_SH)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_SH]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_SH)]]

   set var(DQSG_SK_EFFECT) [expr ($var(BD_PKG_SKEW)-$var(DEFAULT_BD_PKG_SKEW))*$var(BD_SK_SENS_DQSG)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_SK_EFFECT]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_SK_EFFECT)]]

   set var(DQSG_MARGIN) [expr $var(DQSG_UI)-$var(DQSG_ISI)-$var(DQSG_SSI)-$var(DQSG_DQSCK)-$var(DQSG_MPR)-$var(DQSG_JITTER)-$var(DQSG_DCD)-$var(DQSG_EOL)-$var(DQSG_CAL_UNC)-$var(DQSG_TRK_UNC)-$var(DQSG_SH)-$var(DQSG_SK_EFFECT)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter DQSG_MARGIN]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(DQSG_MARGIN)]]

   
   #######################################
   #######################################
   # Create the DQS Gating analysis panel   
   set setup_slack [expr $var(DQSG_MARGIN)/2]
   set hold_slack  [expr $var(DQSG_MARGIN)/2]

   set panel_name "$inst $analysis_name"
   set root_folder_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_current_timequest_report_folder]
   
   if { ! [string match "${root_folder_name}*" $panel_name] } {
      set panel_name "${root_folder_name}||$panel_name"
   }
   # Create the root if it doesn't yet exist
   if {[get_report_panel_id $root_folder_name] == -1} {
      set panel_id [create_report_panel -folder $root_folder_name]
   }

   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }
   
   if {($setup_slack < 0) || ($hold_slack <0)} {
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   add_row_to_table -id $panel_id [list "Operation" "Margin"]
   
   foreach summary_line $summary {
      add_row_to_table -id $panel_id $summary_line -fcolors $positive_fcolour
   }
   
   lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $setup_slack] [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $hold_slack]]
}

#############################################################
# Write Levelling Analysis
#############################################################
proc top_emif_0_altera_emif_arch_nf_191_bclhany_perform_write_levelling_analysis  {opcname inst pin_array_name var_array_name summary_name} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0   
   set result 1

   # Do not perform for QDRII
   if {([string compare $var(PROTOCOL) "QDRII"] == 0)} {
      return
   }
   
   # Only perform for DDR protocols 
   if { ([string compare $var(PROTOCOL) "DDR4"] == 0) || ([string compare $var(PROTOCOL) "DDR3"] == 0) || ([string compare $var(PROTOCOL) "LPDDR3"] == 0)} {
      set analysis_name "Write Levelling"
   } else {
      set analysis_name "DK vs CK"
   }   

   ###############################
   # Write Levelling summary report
   ###############################

   set positive_fcolour [list "black" "blue"]
   set negative_fcolour [list "black" "red" ]

   set summary [list]
   
   set var(WL_UI) [expr $var(UI)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_UI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_UI)]]

   set var(WL_ISI) $var(WL_ISI)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_ISI]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_ISI)]]

   set var(WL_SSO) $var(WL_SSO)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_SSO]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_SSO)]]

   set var(WL_MEM) [expr $var(tCK)*(1-2*[min [expr $var(tDQSS)] [expr (1-$var(tDSS)-$var(tDSH))/2]])]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_MEM]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_MEM)]]

   set var(WL_MPR) [expr ($var(WITH_WL_CALIB) == 1 ? ($var(WITH_MPR) == 1 ? -$var(WL_MEM)*$var(MPR_DQSS) : 0) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_MPR]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_MPR)]]

   set var(WL_SH) [expr ($var(WITH_WL_M_CALIB) == 1 ? (1-$var(MPR_WLS))*$var(tWLS) + (1-$var(MPR_WLH))*$var(tWLH) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_SH]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_SH)]]

   set var(WL_JITTER) $var(WL_JITTER)
   set var(WL_JITTER_sens) [expr ([expr (($var(UI))*1000.0-$var(EXTRACTED_PERIOD))*$var(WL_JITTER_SENS_TO_PERIOD)])/1000.0]
   if {$var(WL_JITTER_sens) > 0} {
      set var(WL_JITTER) [expr $var(WL_JITTER) + $var(WL_JITTER_sens)]
   }
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_JITTER]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_JITTER)]]

   set var(WL_DCD) $var(WL_DCD)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_DCD]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_DCD)]]

   set var(WL_EOL) $var(WL_EOL)
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_EOL]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_EOL)]]

   set var(WL_CAL_UNC) [expr ($var(WITH_WL_CALIB) == 1 ? $var(WL_CALIBRATION_LOSS_OTHER)+($var(OCT_RECAL) == 1 ? $var(WL_TEMP_CAL_LOSS_OCT_RECAL) : $var(WL_TEMP_CAL_LOSS_WO_OCT_RECAL)) : 0)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_CAL_UNC]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_CAL_UNC)]]

   set var(WL_PVT) [expr ($var(WITH_WL_CALIB) == 1 ? 0 : $var(WL_CALIBRATION_LOSS_OTHER)+($var(OCT_RECAL) == 1 ? $var(WL_TEMP_CAL_LOSS_OCT_RECAL_WO_WL_CAL) : $var(WL_TEMP_CAL_LOSS_WO_OCT_RECAL_WO_WL_CAL)))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_PVT]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_PVT)]]

   set var(WL_SK_EFFECT) [expr ($var(WITH_WL_CALIB) == 1 ? ($var(BD_PKG_SKEW)-$var(DEFAULT_BD_PKG_SKEW))*$var(BD_SK_SENS_WL) : ($var(BD_PKG_SKEW)-$var(DEFAULT_BD_PKG_SKEW))*$var(BD_SK_SENS_WL_WO_CALIB)+$var(DQS_TO_CK_BOARD_SKEW)+$var(DQS_BOARD_SKEW))]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_SK_EFFECT]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_SK_EFFECT)]]

   set var(WL_MARGIN) [expr $var(WL_UI)-$var(WL_ISI)-$var(WL_SSO)-$var(WL_MEM)-$var(WL_MPR)-$var(WL_SH)-$var(WL_JITTER)-$var(WL_DCD)-$var(WL_EOL)-$var(WL_CAL_UNC)-$var(WL_PVT)-$var(WL_SK_EFFECT)]
   lappend summary [list "   [emiftcl_get_parameter_user_string -parameter WL_MARGIN]" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $var(WL_MARGIN)]]


   #######################################
   #######################################
   # Create the Write Levelling analysis panel   
   set setup_slack [expr $var(WL_MARGIN)/2]
   set hold_slack  [expr $var(WL_MARGIN)/2]

   set panel_name "$inst $analysis_name"
   set root_folder_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_current_timequest_report_folder]
   
   if { ! [string match "${root_folder_name}*" $panel_name] } {
      set panel_name "${root_folder_name}||$panel_name"
   }
   # Create the root if it doesn't yet exist
   if {[get_report_panel_id $root_folder_name] == -1} {
      set panel_id [create_report_panel -folder $root_folder_name]
   }

   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }
   
   if {($setup_slack < 0) || ($hold_slack <0)} {
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   add_row_to_table -id $panel_id [list "Operation" "Margin"]      
   
   foreach summary_line $summary {
      add_row_to_table -id $panel_id $summary_line -fcolors $positive_fcolour
   }
   
   lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $setup_slack] [top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp $hold_slack]]
}

################################################################
# Helper function to add a report_timing-based analysis section
################################################################
proc top_emif_0_altera_emif_arch_nf_191_bclhany_add_report_timing_analysis {opcname inst var_array_name summary_name title from_clks to_clks from_nodes to_nodes } {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   
   set num_failing_path 10
   
   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9
      
   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -setup]] > 0} {
      set res_0        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (setup)" -setup]
      set res_1        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (hold)" -hold]
      set setup_margin [lindex $res_0 1]
      set hold_margin  [lindex $res_1 1]
      
      if {$var(DIAG_TIMING_REGTEST_MODE)} {
         lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
      }
   }
   
   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0} {
      set res_0           [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (recovery)" -recovery]
      set res_1           [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (removal)" -removal]
      set recovery_margin [lindex $res_0 1]
      set removal_margin  [lindex $res_1 1]
      
      if {$var(DIAG_TIMING_REGTEST_MODE)} {
         lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
      }
   }
   
   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}

#############################################################
# Other Core-Logic related Timing Analysis
#############################################################

proc top_emif_0_altera_emif_arch_nf_191_bclhany_add_c2p_p2c_report_timing_analysis {opcname inst pin_array_name var_array_name summary_name title from_clks to_clks from_nodes to_nodes p2c} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   set num_failing_path 10

   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9
   set debug 0

   set positive_fcolour [list "black" "blue" "blue"]
   set negative_fcolour [list "black" "red"  "red"]
   set summary [list]

   # Get the periphery clocks
   if {$p2c} {
      set phyclks $from_clks
   } else {
      set phyclks $to_clks
   }

   # Set panel names
   set panel_name_setup  "$inst $title (setup)"
   set panel_name_hold   "$inst $title (hold)"
   set panel_name_recovery  "$inst $title (recovery)"
   set panel_name_removal   "$inst $title (removal)"	  
   set disable_panel_color_flag ""
   set quiet_flag ""

   # Generate the default margins
   set res_0        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_setup -setup $disable_panel_color_flag $quiet_flag]
   set res_1        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_hold -hold $disable_panel_color_flag $quiet_flag]
   set recovery_removal_paths 0
   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0} {
      set recovery_removal_paths 1
      set res_2        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_recovery -recovery $disable_panel_color_flag $quiet_flag]
      set res_3        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_removal  -removal  $disable_panel_color_flag $quiet_flag]
   }
   set setup_margin [lindex $res_0 1]
   set hold_margin  [lindex $res_1 1]
   if {$recovery_removal_paths == 1} {
     set recovery_margin [lindex $res_2 1]
	 set removal_margin  [lindex $res_3 1]
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
      if {$recovery_removal_paths == 1} {
         lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $hold_margin]
      }
   }

   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_perform_core_analysis {opcname inst pin_array_name var_array_name summary_name} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins
   global ::io_only_analysis

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0   
   set result 1

   ###############################
   # PHY analysis
   ###############################
   
   set analysis_name "Core"

   if {$::io_only_analysis == 1} {
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      post_message -type warning "Early EMIF IO timing estimate does not include core FPGA timing"
   } elseif {$var(IS_HPS)} {
      # No core timing analysis required by HPS interface
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $setup_slack $hold_slack]
   } else {
   
      set master_instname $pins(master_instname)
      set coreclkname [list ${master_instname}_core_usr_* ${master_instname}_core_afi_* ${master_instname}_core_dft_* ${master_instname}_ref_clock ${master_instname}_core_nios_clk ${inst}_oct_clock ${inst}_oct_gated_clock [top_emif_0_altera_emif_arch_nf_191_bclhany_get_clock_name_from_pin_name $pins(pll_ref_clock)]]
      set coreclks [get_clocks -nowarn $coreclkname]
      
      set phyclkname [list ${inst}_phy_*]
      set phyclks [get_clocks -nowarn $phyclkname]
   
      set emif_regs [get_registers $inst|*] 
      set rest_regs [remove_from_collection [all_registers] $emif_regs]
      
      set setup_margin    999.9
      set hold_margin     999.9
      set recovery_margin 999.9
      set removal_margin  999.9

      # Core/periphery transfers

      # Core-to-periphery
      set res [top_emif_0_altera_emif_arch_nf_191_bclhany_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Core To Periphery" $coreclks $phyclks "*" $emif_regs 0]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]
      
      # Periphery-to-core
      set res [top_emif_0_altera_emif_arch_nf_191_bclhany_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Periphery To Core" $phyclks $coreclks $emif_regs "*" 1]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Pure Core transfers

      set_active_clocks [remove_from_collection [all_clocks] $phyclks]

      # EMIF logic within FPGA core
      set res [top_emif_0_altera_emif_arch_nf_191_bclhany_add_report_timing_analysis $opcname $inst var global_summary "Within Core" $coreclks $coreclks $emif_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]
      
      # Transfers between EMIF and user logic
      set res [top_emif_0_altera_emif_arch_nf_191_bclhany_add_report_timing_analysis $opcname $inst var global_summary "IP to User Logic" "*" "*" $emif_regs $rest_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]
      
      # Transfers between user and EMIF logic
      set res [top_emif_0_altera_emif_arch_nf_191_bclhany_add_report_timing_analysis $opcname $inst var global_summary "User Logic to IP" "*" "*" $rest_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]
      
      # Transfers within non-EMIF logic (not reported by default since they are irrelevant to EMIF IP)
      if {$var(DIAG_TIMING_REGTEST_MODE)} {
         set res [top_emif_0_altera_emif_arch_nf_191_bclhany_add_report_timing_analysis $opcname $inst var global_summary "Within User Logic" $coreclks $coreclks $rest_regs $rest_regs]
         set setup_margin    [min $setup_margin    [lindex $res 0]]
         set hold_margin     [min $hold_margin     [lindex $res 1]]
         set recovery_margin [min $recovery_margin [lindex $res 2]]
         set removal_margin  [min $removal_margin  [lindex $res 3]]
      }

      set_active_clocks [all_clocks]

      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_margin $hold_margin]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
   }
}


 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 23 altera_emif_arch_nf_191 5 synth 52 top_emif_0_altera_emif_arch_nf_191_bclhany_utils.tcl 19243 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.



set script_dir [file dirname [info script]]

load_package sdc_ext
load_package design

proc top_emif_0_altera_emif_arch_nf_191_bclhany_index_in_collection { col j } {
   set i 0
   foreach_in_collection path $col {
      if {$i == $j} {
         return $path
      }
      set i [expr $i + 1]
   }
   return ""
}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_clock_to_pin_name_mapping {} {
   set result [list]
   set clocks_collection [get_clocks]
   foreach_in_collection clock $clocks_collection {
      set clock_name [get_clock_info -name $clock]
      set clock_target [get_clock_info -targets $clock]
      set first_index [top_emif_0_altera_emif_arch_nf_191_bclhany_index_in_collection $clock_target 0]
      set catch_exception_net [catch {get_net_info -name $first_index} pin_name_net]
      if {$catch_exception_net == 0} {
         lappend result [list $clock_name $pin_name_net]
      } else {
         set catch_exception_port [catch {get_port_info -name $first_index} pin_name_port]
         if {$catch_exception_port == 0} {
            lappend result [list $clock_name $pin_name_port]
         } else {
            set catch_exception_reg [catch {get_register_info -name $first_index} pin_name_reg]
            if {$catch_exception_reg == 0} {
               lappend result [list $clock_name $pin_name_reg]
            } else {
               set catch_exception_pin [catch {get_pin_info -name $first_index} pin_name_pin]
               if {$catch_exception_pin == 0} {
                  lappend result [list $clock_name $pin_name_pin]
               }
            }
         }
      }
   }
   return $result
}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_clock_name_from_pin_name { pin_name } {
   set table [top_emif_0_altera_emif_arch_nf_191_bclhany_get_clock_to_pin_name_mapping]
   foreach entry $table {
      if {[string compare [lindex [lindex [split $entry] 1] 0] $pin_name] == 0} {
         return [lindex $entry 0]
      }
   }
   return ""
}



proc top_emif_0_altera_emif_arch_nf_191_bclhany_find_all_keepers { mystring } {
   set allkeepers [get_keepers $mystring ]

   foreach_in_collection keeper $allkeepers {
      set keepername [ get_node_info -name $keeper ]

      puts "$keepername"
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_round_3dp { x } {
   return [expr { round($x * 1000) / 1000.0  } ]
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_current_timequest_report_folder {} {

   set catch_exception [catch {get_current_timequest_report_folder} error_message]
   if {[regexp ERROR $error_message] == 1} {
      return "ReportDDR"
   } else {
      return [get_current_timequest_report_folder]
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_timequest_name {hier_name} {
   set sta_name $hier_name
   return $sta_name
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_are_entity_names_on { } {
   return [set_project_mode -is_show_entity]
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_instance_list {corename} {
   global ::io_only_analysis

   if {$::io_only_analysis == 1}  {
      set instance_list [list $corename]

   } else {
      set full_instance_list [top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_full_instance_list $corename]
      set instance_list [list]

      foreach inst $full_instance_list {
         set sta_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_timequest_name $inst]
         if {[lsearch $instance_list [escape_brackets $sta_name]] == -1} {
            lappend instance_list $sta_name
         }
      }

   }
   return $instance_list
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_or_add_generated_clock {args} {
   array set opts { /
      -name "" /
      -target "" /
      -source "" /
      -multiply_by 1 /
      -divide_by 1 /
      -phase 0 }

   array set opts $args

   set multiply_by [expr int($opts(-multiply_by))]
   if {[expr $multiply_by - $opts(-multiply_by)] != 0.0} {
      post_message -type error "Specify an integer ranging from 0 to 99999999 for the option -multiply_by"
      return ""
   }

   set clock_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_clock_name_from_pin_name $opts(-target)]

   if {[string compare -nocase $clock_name ""] == 0} {
      set nets [get_nets $opts(-target) -nowarn]
      if {[get_collection_size $nets] > 0} {
         set pin_name [get_pin_info -name [get_net_info -pin $nets]]
         set clock_name [top_emif_0_altera_emif_arch_nf_191_bclhany_get_clock_name_from_pin_name $pin_name]

         if {[string compare -nocase $clock_name ""] != 0} {
            if {[regexp -nocase "lvds_clk" $pin_name] || [regexp -nocase "loaden" $pin_name] } {
               remove_clock $clock_name
               set clock_name ""
            }
          }
       }
   } else {
      if {([string compare -nocase $opts(-name) ""] != 0) && ([string compare -nocase $opts(-name) $clock_name])} {

         if {[regexp -nocase "pll_inst\|outclk" $opts(-target)]} {
            remove_clock $clock_name
            set clock_name ""
         }
      }
   }

   if {[string compare -nocase $clock_name ""] == 0} {
      set clock_name $opts(-name)

      create_generated_clock \
         -name $clock_name \
         -source $opts(-source) \
         -multiply_by $multiply_by \
         -divide_by $opts(-divide_by) \
         -phase $opts(-phase) \
         $opts(-target)
   }

   return $clock_name
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_core_full_instance_list {corename} {

   set instance_list [list]

   if {[is_fitter_in_qhd_mode]} {
      set instance_list_pre [design::get_instances -entity $corename]

   } else {
      set instance_list_pre [get_entity_instances $corename]
   }

   foreach instance $instance_list_pre {
      regsub {\|arch$} $instance "" instance_no_arch
      lappend instance_list $instance_no_arch
   }

   if {[ llength $instance_list ] == 0} {
      post_message -type error "The auto-constraining script was not able to detect any instance for core < $corename >"
      post_message -type error "Make sure the core < $corename > is instantiated within another component (wrapper)"
      post_message -type error "and it's not the top-level for your project"
   }

   return $instance_list
}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
   upvar 1 $results_array_name results

   if {$depth < 0} {
      error "Internal error: Bad timing netlist search depth"
   }
   set fanin_edges [get_node_info -${edge_type}_edges $node_id]
   set number_of_fanin_edges [llength $fanin_edges]
   for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
      set fanin_edge [lindex $fanin_edges $i]
      set fanin_id [get_edge_info -src $fanin_edge]
      if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
         set results($fanin_id) 1
      } elseif {$depth == 0} {
      } else {
         top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
      }
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_is_node_type_pin { node_id } {
   set node_type [get_node_info -type $node_id]
   if {$node_type == "port"} {
      set result 1
   } else {
      set result 0
   }
   return $result
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_pll_clock_name { clock_id } {
   set clock_name [get_node_info -name $clock_id]

   return $clock_name
}

proc post_sdc_message {msg_type msg} {
   global ::io_only_analysis

   if {($::io_only_analysis == 1) || $::TimeQuestInfo(nameofexecutable) != "quartus_fit"} {
      post_message -type $msg_type $msg
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_names_in_collection { col } {
   set res [list]
   foreach_in_collection node $col {
      lappend res [ get_node_info -name $node ]
   }
   return $res
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_format_3dp { x } {
   return [format %.3f $x]
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_colours { x y } {

   set fcolour [list "black"]
   if {$x < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }
   if {$y < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }

   return $fcolour
}

proc min { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a < $b } {
      return $a
   } else {
      return $b
   }
}

proc max { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a > $b } {
      return $a
   } else {
      return $b
   }
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_max_in_collection { col attribute } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set max [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp > $max} {
            set max $temp
         }
      }
      set i [expr $i + 1]
   }
   return $max
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_min_in_collection { col attribute } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set min [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp < $min} {
            set min $temp
         }
      }
      set i [expr $i + 1]
   }
   return $min
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_min_in_collection_to_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -to_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_min_in_collection_from_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -from_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_min_in_collection_to_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_min_in_collection_from_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_max_in_collection_to_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_max_in_collection_from_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}


proc top_emif_0_altera_emif_arch_nf_191_bclhany_min_in_collection_to_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_min_in_collection_from_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_max_in_collection_to_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_max_in_collection_from_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_sort_proc {a b} {
   set idxs [list 1 2 0]
   foreach i $idxs {
      set ai [lindex $a $i]
      set bi [lindex $b $i]
      if {$ai > $bi} {
         return 1
      } elseif { $ai < $bi } {
         return -1
      }
   }
   return 0
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_gcd {p q} {
   set p [expr {abs($p)}]
   set q [expr {abs($q)}]
   while {$q != 0} {
      set r [expr {$p % $q}]
      set p $q
      set q $r
   }
   return $p
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_atom_path {atom_id atom_oport_id path} {
   # Return list of {atom oterm_id} pairs by tracing the atom netlist starting from the given atom_id through the given path
   # Path consists of list of {atom_type fanin|fanout|end <port_type> <-optional>}
   set result [list]
   if {[llength $path] > 0} {
      set path_point [lindex $path 0]
      set atom_type [lindex $path_point 0]
      set next_direction [lindex $path_point 1]
      set port_type [lindex $path_point 2]
      set atom_optional [lindex $path_point 3]
      if {[get_atom_node_info -key type -node $atom_id] == $atom_type} {
         if {$next_direction == "end"} {
            if {[get_atom_port_info -key type -node $atom_id -port_id $atom_oport_id -type oport] == $port_type} {
               lappend result [list $atom_id $atom_oport_id]
            }
         } elseif {$next_direction == "atom"} {
            lappend result [list $atom_id]
         } elseif {$next_direction == "fanin"} {
            set atom_iport [get_atom_iport_by_type -node $atom_id -type $port_type]
            if {$atom_iport != -1} {
               set iport_fanin [get_atom_port_info -key fanin -node $atom_id -port_id $atom_iport -type iport]
               set source_atom [lindex $iport_fanin 0]
               set source_oterm [lindex $iport_fanin 1]
               set result [top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_atom_path $source_atom $source_oterm [lrange $path 1 end]]
            } elseif {$atom_optional == "-optional"} {
               set result [top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
            }
         } elseif {$next_direction == "fanout"} {
            set atom_oport [get_atom_oport_by_type -node $atom_id -type $port_type]
            if {$atom_oport != -1} {
               set oport_fanout [get_atom_port_info -key fanout -node $atom_id -port_id $atom_oport -type oport]
               foreach dest $oport_fanout {
                  set dest_atom [lindex $dest 0]
                  set dest_iterm [lindex $dest 1]
                  set fanout_result_list [top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_atom_path $dest_atom -1 [lrange $path 1 end]]
                  foreach fanout_result $fanout_result_list {
                     if {[lsearch $result $fanout_result] == -1} {
                        lappend result $fanout_result
                     }
                  }
               }
            }
         } else {
            error "Unexpected path"
         }
      } elseif {$atom_optional == "-optional"} {
         set result [top_emif_0_altera_emif_arch_nf_191_bclhany_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
      }
   }
   return $result
}

proc top_emif_0_altera_emif_arch_nf_191_bclhany_get_operating_conditions_number {} {
   set cur_operating_condition [get_operating_conditions]
   set counter 0
   foreach_in_collection op [get_available_operating_conditions] {
      if {[string compare $cur_operating_condition $op] == 0} {
         return $counter
      }
      incr counter
   }
   return $counter
}
 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 16 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 2 ip 6 top_hw 10 top_emif_0 27 altera_reset_controller_191 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 14 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 6 top_hw 25 altera_avalon_dc_fifo_191 5 synth 44 top_hw_altera_avalon_dc_fifo_191_7gx45aq.sdc 4766 #-------------------------------------------------------------------------------
# TimeQuest constraints to constrain the timing across asynchronous clock domain crossings.
# The idea is to minimize skew to less than one launch clock period to keep the gray encoding, 
# and to minimize latency on the pointer crossings.
#
# The paths are from the Gray Code read and write pointers to their respective synchronizer banks.
#
# *** Important note *** 
#
# Do not declare the FIFO clocks as asynchronous at the top level, or false path these crossings,
# because that will override these constraints.
#-------------------------------------------------------------------------------
set all_dc_fifo [get_entity_instances top_hw_altera_avalon_dc_fifo_191_7gx45aq]

set_max_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|in_wr_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_max_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 200
set_min_delay -from [get_registers {*|out_rd_ptr_gray[*]}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] -200

set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|in_wr_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:write_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}] 
set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from [get_pins -compatibility_mode {*|out_rd_ptr_gray[*]*}] -to [get_registers {*|altera_dcfifo_synchronizer_bundle:read_crosser|altera_std_synchronizer_nocut:sync[*].u|din_s1}]


foreach dc_fifo_inst $all_dc_fifo {
   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|in_wr_ptr_gray[*]]]] > 0  } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|in_wr_ptr_gray[*]] -to [get_registers $dc_fifo_inst|write_crosser|sync[*].u|din_s1] 
   }

   if { [ llength [query_collection -report -all [get_registers -nowarn $dc_fifo_inst|out_rd_ptr_gray[*]]]] > 0 } {
      set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8  -from [get_registers $dc_fifo_inst|out_rd_ptr_gray[*]] -to [get_registers $dc_fifo_inst|read_crosser|sync[*].u|din_s1] 
   }
}


# add in timing constraints across asynchronous clock domain crossings for simple dual clock memory inference

set mem_regs [get_registers -nowarn *|top_hw_altera_avalon_dc_fifo_191_7gx45aq:*|mem*];
if {![llength [query_collection -report -all $mem_regs]] > 0} {
    set mem_regs [get_registers -nowarn top_hw_altera_avalon_dc_fifo_191_7gx45aq:*|mem*];
}

set internal_out_payload_regs [get_registers -nowarn *|top_hw_altera_avalon_dc_fifo_191_7gx45aq:*|internal_out_payload*];
if {![llength [query_collection -report -all $internal_out_payload_regs]] > 0} {
    set internal_out_payload_regs [get_registers -nowarn top_hw_altera_avalon_dc_fifo_191_7gx45aq:*|internal_out_payload*];
}

if {[llength [query_collection -report -all $internal_out_payload_regs]] > 0 && [llength [query_collection -report -all $mem_regs]] > 0} {
    set_max_delay -from $mem_regs -to $internal_out_payload_regs 200
    set_min_delay -from $mem_regs -to $internal_out_payload_regs -200

    set_net_delay -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8 -from $mem_regs -to $internal_out_payload_regs

    #set_max_skew 2 -from $mem_regs -to $internal_out_payload_regs
}

# -----------------------------------------------------------------------------
# This procedure constrains the skew between the pointer bits, and should
# be called from the top level SDC, once per instance of the FIFO.
#
# The hierarchy path to the FIFO instance is required as an 
# argument.
# -----------------------------------------------------------------------------
proc constrain_altera_avalon_dc_fifo_ptr_skew { path } {

    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|in_wr_ptr_gray\[*\] ] -to [ get_registers $path|write_crosser|sync\[*\].u|din_s1 ]
    set_max_skew -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8 -from [ get_registers $path|out_rd_ptr_gray\[*\] ] -to [ get_registers $path|read_crosser|sync\[*\].u|din_s1 ]

}

 14 0 1 / 4 home 5 ebots 5 EBOTS 4 FPGA 8 Projects 34 FPGA_PCIE_Gen3x8_AVMM_DMA_w_XAVIER 14 00_FPGA_Design 35 Arria10_PCIeGen3x8_DMA_19_2_project 8 platform 6 top_hw 27 altera_reset_controller_191 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 0
